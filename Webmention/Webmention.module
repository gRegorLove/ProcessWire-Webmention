<?php namespace ProcessWire;
/**
 * Webmention module
 *
 * Provides webmention support for ProcessWire
 *
 * @author Gregor Morrill, https://gregorlove.com
 * @see https://webmention.net/
 */

use DateTime;
use DateTimeZone;
use DOMDocument;
use PDO;
use Mf2;
use BarnabyWalters\Mf2 as Mf2helper;
use GregorMorrill\ProcessWireShim;
use ProcessWire\LazyCron;

$dirname = dirname(__FILE__);
require_once($dirname . '/vendor/autoload.php');
require_once($dirname . '/GregorMorrill/Webmention/WireHttp.php');

class Webmention extends WireData implements Module, ConfigurableModule
{
	/**
	 * Reference to the Webmention Field object used by this module
	 * @var Field
	 * @access protected
	 */
	protected $webmention_field = null;

	/**
	 * HTTP response codes
	 * @var array
	 * @access protected
	 */
	protected $http_response_codes = [
		200	=> 'OK',
		202	=> 'Accepted',
		400	=> 'Bad Request',
		404	=> 'Not Found',
		449 => 'Retry With',
		500	=> 'Internal Server Error',
	];

	/**
	 * Provide module information to ProcessWire
	 * @access public
	 * @return array
	 */
	public static function getModuleInfo()
	{
		return [
			'title'		=> 'Webmention',
			'version'	=> 200,
			'summary'	=> 'Webmention is a simple way to automatically notify any URL when you link to it on your site. From the receiver’s perspective, it is a way to request notification when other sites link to it.',
			'href'		=> 'https://webmention.net/',
			'singular'	=> true,
			'autoload'	=> true,
			'installs'	=> [
				'FieldtypeWebmentions',
				'InputfieldWebmentions',
				'ProcessWebmentionsManager',
			],
			'requires' => [
				'PHP>=5.6',
			],
		];
	}

	/**
	 * Current database schema for non-fieldtype database tables
	 * @var int SCHEMA_VERSION
	 */
	const SCHEMA_VERSION = 3;

	/**
	 * This method gets the module's default config data
	 * @access public
	 * @return array
	 */
	public static function getDefaultData()
	{
		return [
			'fields_to_parse' => 'body',
			'http_https_same' => 1,
			'verbose_logging' => 1,
			'process_referers' => 1,
			'is_vouch_required' => 0,
			'schema_version' => self::SCHEMA_VERSION,
		];
	}

	/**
	 * This method handles setting up the module's configuration fields
	 * @param array $data
	 * @access public
	 * @return InputfieldWrapper
	 */
	public static function getModuleConfigInputFields(array $data)
	{
		$inputfields = new InputfieldWrapper();

		# frequencty to process received webmentions
		$field = wire('modules')->get('InputfieldSelect');
		$field->label = 'Frequency to automatically process received webmentions';
		$field->attr('name+id', 'frequency_to_process');
		$field->columnWidth = 50;

		$options = [
			0 => 'Disabled',
			1 => '1 minute',
			2 => '2 minutes',
			3 => '3 minutes',
			4 => '4 minutes',
			5 => '5 minutes',
			10 => '10 minutes',
			15 => '15 minutes',
			30 => '30 minutes',
			45 => '45 minutes',
			60 => '60 minutes',
		];

		$field->addOptions($options);

		if ( isset($data['frequency_to_process']) )
		{
			$field->value = $data['frequency_to_process'];
		}
		else
		{
			$field->value = 0;
		}

		$inputfields->add($field);

		# ProcessWire fields to parse
		$field = wire('modules')->get('InputfieldText');
		$field->name = 'fields_to_parse';
		$field->label = 'Fields to parse for URLs';
		$field->description = 'Enter a comma-separated list of field names.';
		$field->columnWidth = 50;

		if ( isset($data['fields_to_parse']) )
		{
			$field->value = $data['fields_to_parse'];
		}
		else
		{
			$field->value = 'body';
		}

		$inputfields->add($field);

		# webmention custom endpoint
		$field = wire('modules')->get('InputfieldText');
		$field->name = 'custom_endpoint';
		$field->label = 'Custom webmention endpoint URL';
		$field->description = 'If your webmention endpoint is at a different URL, enter it here. Otherwise, leave blank.';
		$field->columnWidth = 50;

		if ( isset($data['custom_endpoint']) )
		{
			$field->value = $data['custom_endpoint'];
		}

		$inputfields->add($field);

		# Treat http and https incoming links the same
		$field = wire('modules')->get('InputfieldCheckbox');
		$field->name = 'http_https_same';
		$field->label = 'Treat http and https as the same';
		$field->checked = ( $data['http_https_same'] ) ? 'checked' : '';
		$field->description = 'Incoming links http://example.com and https://example.com are the same page';
		$field->columnWidth = 50;

		$inputfields->add($field);

		# Verbose logging
		$field = wire('modules')->get('InputfieldCheckbox');
		$field->name = 'verbose_logging';
		$field->label = 'Enable verbose logging';
		$field->checked = ( $data['verbose_logging'] ) ? 'checked' : '';
		$field->description = 'Verbose logging includes webmention endpoint discovery, sending, and receiving. Regular logging will only include errors.';
		$field->columnWidth = 50;

		$inputfields->add($field);

		# Process referer URLs
		$field = wire('modules')->get('InputfieldCheckbox');
		$field->name = 'process_referers';
		$field->value = 0;
		$field->checked = ( $data['process_referers'] ) ? 'checked' : '';
		$field->label = 'Process referer URLs for potential vouches';
		$field->description = 'If a referring URL links back to your site, it may be used as a vouch when sending webmentions';
		$field->columnWidth = 50;

		$inputfields->add($field);

		# Require received webmentions include a Vouch URL
		$field = wire('modules')->get('InputfieldCheckbox');
		$field->name = 'is_vouch_required';
		$field->value = 0;
		$field->checked = ( $data['is_vouch_required'] ) ? 'checked' : '';
		$field->label = 'Require webmention with vouch';
		$field->description = 'Vouch is currently in beta.';
		$field->columnWidth = 50;

		$inputfields->add($field);

		# monitor for approved vouch domains
		$field = wire('modules')->get('InputfieldText');
		$field->name = 'vouch_whitelist';
		$field->label = 'Vouch whitelist URL';
		$field->description = 'You can enter the URL of your blogroll or other whitelist. It will be monitored periodically and new domains will be added to the list of approved vouch domains. No domains will be removed from the approved vouch domains.';
		$field->columnWidth = 50;

		if ( isset($data['vouch_whitelist']) )
		{
			$field->value = $data['vouch_whitelist'];
		}

		$inputfields->add($field);

		# Domains accepted as Vouch URLs
		$field = wire('modules')->get('InputfieldTextarea');
		$field->name = 'approved_vouches';
		$field->label = 'Approved vouch domains';
		$field->description = 'Enter domains you will accept as vouches.';
		$field->columnWidth = 50;

		if ( isset($data['approved_vouches']) )
		{
			$field->value = $data['approved_vouches'];
		}

		$inputfields->add($field);

		return $inputfields;
	}

	/**
	 * Module constructor
	 * @access public
	 */
	public function __construct()
	{
		foreach ( self::getDefaultData() as $key => $value )
		{
			$this->$key = $value;
		}
	}

	/**
	 * This method handles installing the module
	 * @access public
	 */
	public function ___install()
	{

		# webmention template does not exist yet
		if ( is_null($this->templates->get('webmention-endpoint')) )
		{
			# add a field group for the webmention endpoint template
			$fg = new Fieldgroup();
			$fg->name = 'webmention-endpoint';
			$fg->add($this->fields->get('title'));
			$fg->save();

			# add the webmention-endpoint template
			$t = new Template();
			$t->label = 'Webmention Endpoint';
			$t->name = 'webmention-endpoint';
			$t->filename = 'webmention-endpoint';
			$t->fieldgroup = $fg;
			$t->save();

			# add a page using the webmention-endpoint template
			$p = new Page();
			$p->template = 'webmention-endpoint';
			$p->parent = 1;
			$p->title = 'Webmention Endpoint';
			$p->save();
		}

		# save the default module configuration
		$this->modules->saveModuleConfigData($this, self::getDefaultData());

		$sql = <<< END
CREATE TABLE IF NOT EXISTS `{$this->className}_send_queue` (
	`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
	`pages_id` int(10) unsigned NOT NULL DEFAULT '0',
	`source` varchar(255) NOT NULL DEFAULT '',
	`target` varchar(255) NOT NULL DEFAULT '',
	`vouch` varchar(255) NOT NULL DEFAULT '',
	`params` text,
	`created` datetime NOT NULL,
	`modified` datetime NOT NULL,
	`processed` datetime DEFAULT NULL,
	PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8
END;
		$this->database->query($sql);

		$sql = <<< END
CREATE TABLE IF NOT EXISTS `{$this->className}_referer_queue` (
	`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
	`url` varchar(255) NOT NULL DEFAULT '',
	`created` datetime NOT NULL,
	`modified` datetime NOT NULL,
	`processed` datetime DEFAULT NULL,
	PRIMARY KEY (`id`),
	UNIQUE KEY `url` (`url`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8
END;
		$this->database->query($sql);

		$sql = <<< END
CREATE TABLE IF NOT EXISTS `{$this->className}_vouches` (
	`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
	`domain` varchar(255) NOT NULL DEFAULT '',
	`url` varchar(255) NOT NULL DEFAULT '',
	`created` datetime NOT NULL,
	`modified` datetime NOT NULL,
	`deleted` datetime DEFAULT NULL,
	PRIMARY KEY (`id`),
	UNIQUE KEY `url` (`url`),
	KEY `domain` (`domain`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8
END;
		$this->database->query($sql);
	}

	/**
	 * This method handles uninstalling the module
	 * @access public
	 */
	public function ___unInstall()
	{
		$page = $this->pages->get('template=webmention-endpoint');
		$page->delete();

		$template = $this->templates->get('webmention-endpoint');

		if ( !is_null($template) && $template->getNumPages() == 0 )
		{
			$fg = $template->fieldgroup;

			wire('templates')->delete($template);

			wire('fieldgroups')->delete($fg);
		}

		$this->database->query("DROP TABLE IF EXISTS {$this->className}_send_queue");
		$this->database->query("DROP TABLE IF EXISTS {$this->className}_referer_queue");
		$this->database->query("DROP TABLE IF EXISTS {$this->className}_vouches");
	}

	/**
	 * Initialize the module
	 *
	 * ProcessWire calls this when the module is loaded. For 'autoload' modules, this will be called
	 * when ProcessWire's API is ready. As a result, this is a good place to attach hooks.
	 * @access public
	 */
	public function init()
	{
		$date = new DateTime();
		$this->gmt_offset = $date->format('P');

		# not using the latest schema; upgrade database
		if ( $this->schema_version < self::SCHEMA_VERSION )
		{
			$this->updateDatabaseSchema();
		}

		if ( $this->process_referers )
		{
			$this->addHook('LazyCron::every30Seconds', $this, 'processReferer');
		}

		$this->addHook('LazyCron::every30Seconds', $this, 'sendWebmentions');
		$this->addHook('LazyCron::everyDay', $this, 'processVouchWhitelist');

		# auto-process received webmentions
		if ( $this->frequency_to_process )
		{

			switch ( $this->frequency_to_process )
			{
				case 1:
					$cron_frequency = 'everyMinute';
				break;

				case 60:
					$cron_frequency = 'everyHour';
				break;

				default:
					$cron_frequency = sprintf('every%dMinutes', $this->frequency_to_process);
				break;
			}

			$this->addHook('LazyCron::' . $cron_frequency, $this, 'processWebmentions');
		}


		/**
		 * Add the Webmention endpoint Link: header, if the page supports webmentions
		 */
		$this->addHookBefore('PageRender::renderPage', function($event) {

			if ( $this->process_referers )
			{
				$this->recordReferer();
			}

			$page = $event->page;
			$this->findFieldtypeWebmentions($page);

			# page supports webmentions, send Link: header
			if ( $this->webmention_field )
			{
				$endpoint = ( $this->custom_endpoint ) ? $this->custom_endpoint : $this->pages->get('template=webmention-endpoint')->httpUrl;
				$link = sprintf('Link: <%s>; rel="webmention"', $endpoint);
				header($link, false);
			}

		});


		/**
		 * Receive webmentions when POSTed to the webmention-endpoint template
		 */
		$this->addHookBefore('ProcessPageView::ready', function($event) {

			$page = $event->page;

			if ( $page->template == 'webmention-endpoint' && count($this->input->post) )
			{
				$this->receiveWebmention();
			}

		});


		/**
		 * Add 'Send Webmentions' checkbox to page edit form
		 */
		$this->addHook('ProcessPageEdit::buildForm', function($event) {

			$page = $event->object->getPage();
			$this->findFieldtypeWebmentions($page);

			if ( $this->webmention_field )
			{
				# set up the checkbox field
				$field = $this->modules->get('InputfieldCheckbox');
				$field->attr('id+name', 'send_webmentions');
				$field->attr('value', 1);
				$field->attr('class', $field->class);
				$field->label = 'Send Webmentions';

				# check the box by default on the first page edit
				if ( $page->created === $page->modified )
				{
					$field->attr('checked', 'checked');
				}

				$event->return = $event->return->append($field);
			}

		});


		/**
		 * Perform webmention actions after page save
		 */
		$this->addHook('Pages::saved', function($event) {

			$page = $event->arguments('page');

			# page is published, and user checked 'send webmention'
			if ( !$page->is(Page::statusUnpublished) && $this->input->post->send_webmentions == 1 )
			{
				$fields_to_parse = explode(',', $this->fields_to_parse);

				$urls = [];

				# each field to parse for webmention-able URLs
				foreach ( $fields_to_parse as $field )
				{

					# page has the field; extract URLs
					if ( $page->template->hasField($field) )
					{
						$urls = array_merge($urls, $this->extractURLs($page->{$field}, $page->httpUrl));
					}

				}

				$urls = array_merge($urls, $this->getWebmentionURLs($page->id));
				$urls = array_unique($urls);

				$params = [];

				if ( $page->is_private )
				{
					$params = ['private' => 1];
				}

				if ( $urls )
				{
					$this->queueWebmentions($urls, $page->httpUrl, $page->id, $params);
				}

			}

		});
	}

	/**
	 * This method handles finding if the page has FieldtypeWebmentions
	 * @param Page $page
	 * @access private
	 * @return bool
	 */
	private function findFieldtypeWebmentions(Page $page)
	{

		# each field for this page
		foreach ( $page->template->fields as $field )
		{

			if ( $field->type instanceof FieldtypeWebmentions )
			{
				$this->webmention_field = $field;
				return true;
			}

		}

		return false;
	}

	/**
	 * This method initiates processing received webmentions
	 * @access public
	 * @return bool
	 */
	public function processWebmentions()
	{

		foreach ( $this->fields as $field )
		{

			if ( $field->type instanceof FieldtypeWebmentions )
			{
				$fields[] = $field;
			}

		}

		$count = count($fields);

		if ( !$count )
		{
			return false;
		}

		$field = reset($fields);
		$limit = 5;
		$selector = sprintf('status=%d, limit=%d, type!="legacy", sort=-created', WebmentionItem::statusPending, $limit);

		$webmentions = $field->type->find($field, $selector);

		if ( $webmentions->count() == 0 )
		{
			return true;
		}

		foreach ( $webmentions as $webmention )
		{
			$action = $this->processWebmention($webmention);

			# delete the webmention
			if ( $action == WebmentionItem::actionDelete )
			{

				if ( $field->type->deleteWebmention($webmention->getPage(), $field, $webmention) )
				{
					$this->log->save('webmentions-received', sprintf('Deleted webmention %d.', $webmention->id));
					$this->message(sprintf($this->_('Deleted webmention #%d'), $webmention->id));
				}

				continue;
			}

			$this->saveWebmention($webmention);
		}

		return true;
	}

	/**
	 * Verify the source links to the target
	 * @param string $html source HTML, already retrieved during webmention processing
	 * @param string $source source URL, used to resolve relative links
	 * @param string $target target URL
	 * @access public
	 * @return bool
	 */
	public function verifyLinksTo($html, $source, $target)
	{
		$target_relative = $this->buildRelativeURL($target);
		$target_hostname = strtolower(parse_url($target, PHP_URL_HOST));
		$target_scheme_hostname = strtolower(
			sprintf('%s://%s',
				parse_url($target, PHP_URL_SCHEME),
				parse_url($target, PHP_URL_HOST)
			)
		);

		libxml_use_internal_errors(true);
		$dom = new DOMDocument('1.0', 'UTF-8');
		$dom->loadHTML($html);
		$dom->preserveWhiteSpace = false;

		# get all <a> DOMElements
		$a_elements = $dom->getElementsByTagName('a');

		# each <a> DOMElement
		foreach ( $a_elements as $a )
		{

			# <a> element has href attribute
			if ( $a->hasAttribute('href') )
			{
				$url = Mf2\resolveUrl($source, $a->getAttribute('href'));

				# verify linkback without scheme
				if ( $this->http_https_same )
				{
					$hostname = strtolower(parse_url($url, PHP_URL_HOST));

					# link hostnames match (not case-sensitive) and relative URLs match
					if ( $hostname === $target_hostname && $target_relative === $this->buildRelativeURL($url) )
					{
						return true;
					}

				}
				# verify linkback exactly
				else
				{
					$scheme_hostname = strtolower(
						sprintf('%s://%s',
							parse_url($url, PHP_URL_SCHEME),
							parse_url($url, PHP_URL_HOST)
						)
					);

					# link scheme+hostnames match (not case-sensitive) and relative URLs match
					if ( $scheme_hostname == $target_scheme_hostname && $target_relative = $this->buildRelativeURL($url) )
					{
						return true;
					}

				}

			}

		}

		return false;
	}

	/**
	 * This method processes a webmention
	 * @param WebmentionItem $webmention
	 * @access public
	 * @return bool
	 */
	public function processWebmention(WebmentionItem &$webmention)
	{
		$http = new WireHttp();

		$original_target = $webmention->target_url;
		$original_source = $webmention->source_url;

		## Verify the target URL
		$target_response = $http->get($webmention->target_url);
		$http_code = $http->getHttpCode();

		# webmention target is HTTP 404
		if ( $http_code == 404 )
		{
			$webmention->content = $webmention->name = sprintf('The target URL %s was not found.', $original_target);
			$webmention->status = WebmentionItem::statusError;
			$webmention->visibility = WebmentionItem::visibilityPrivate;
			$this->log->save('webmentions-received', $webmention->name);

			return WebmentionItem::actionProcess;
		}

		$http_headers = $http->getResponseHeaders();

		# redirected; update final URL
		if ( !empty($http_headers['location']) )
		{
			$webmention->target_url = $http_headers['location'];
		}

		## Verify the source URL
		$response = $http->get($webmention->source_url);
		$http_code = $http->getHttpCode();

		# webmention source is HTTP 404
		if ( $http_code == 404 )
		{
			$webmention->content = $webmention->name = sprintf('The source URL %s was not found.', $original_source);
			$webmention->status = WebmentionItem::statusError;
			$webmention->visibility = WebmentionItem::visibilityPrivate;
			$this->log->save('webmentions-received', $webmention->name);

			return WebmentionItem::actionProcess;
		}
		# webmention source is HTTP 410
		else if ( $http_code == 410 )
		{

			if ( $this->verbose_logging )
			{
				$this->log->save('webmentions-received', sprintf('Source URL %s is HTTP 410. Webmention %d will be deleted.', $original_source, $webmention->id));
			}

			return WebmentionItem::actionDelete;
		}

		$http_headers = $http->getResponseHeaders();

		# redirected; update final URL
		if ( !empty($http_headers['location']) )
		{
			$webmention->source_url = $http_headers['location'];
		}

		/**
		 * If the soruce URL is already listed in the target page,
		 * that means this is likely a notification rather than
		 * a mention or reply. Do nothing for now until more experimentation
		 * is done with update/delete and reply-contexts.
		 * Discussion: https://indieweb.org/reply-context#CRUD
		 */

		$source_base_url = parse_url($webmention->source_url, PHP_URL_SCHEME) . '://' . parse_url($webmention->source_url, PHP_URL_HOST);
		$source_pattern = '#(?i)' . $source_base_url . '(?-i)' . preg_replace('#' . $source_base_url . '#i', '', $webmention->source_url) . '#';

		# source URL is already linked from the target; log a simple 'notification' message
		if ( preg_match($source_pattern, $target_response) === 1 )
		{
			$this->log->save('webmentions-received', sprintf('The URL %s sent a notification to %s', $original_source, $original_target));

			return WebmentionItem::actionProcess;
		}

		# target URL linked from source
		if ( $this->verifyLinksTo($response, $webmention->source_url, $original_target) )
		{
			$webmention->status = WebmentionItem::statusApproved;

			# parse HTML for microformats2
			$parsed_content = $this->fetchMicroformats($response, $webmention->source_url);
			$webmention->set('microformats', json_encode($parsed_content, JSON_PRETTY_PRINT));

			# parse first h-entry
			$entry = $this->parseFirstEntry($parsed_content, $webmention);
			$author = null;

			# h-entry found; parse author from h-card
			if ( $entry )
			{
				$author = $this->getAuthorship($entry, $parsed_content, $webmention);
			}
			# no h-entry; generic 'mentioned this' content
			else
			{
				$webmention->content = $webmention->name = sprintf('mentioned this');
			}

			# authorship algorithm did not find an author; use domain name as default author
			if ( !$author )
			{
				$author = $this->parseDefaultAuthor($webmention->source_url, $webmention);
			}

			unset($parsed_content);
			unset($entry);
			unset($author);
		}
		#
		else
		{
			$webmention->content = $webmention->name = sprintf('The URL %s was not found in %s', $webmention->target_url, $webmention->source_url);
			$webmention->status = WebmentionItem::statusError;
			$webmention->visibility = WebmentionItem::visibilityPrivate;

			if ( $this->verbose_logging )
			{
				$this->log->save('webmentions-received', sprintf('Source %s does not link to target.', $webmention->source_url));
			}

			return WebmentionItem::actionProcess;
		}

		return WebmentionItem::actionProcess;
	}

	/**
	 * This method saves a webmention field
	 * @param WebmentionItem $webmention
	 * @access public
	 * @return bool
	 */
	public function saveWebmention(WebmentionItem $webmention)
	{
		$page = $webmention->getPage();
		$field = $webmention->getField();

		$page->{$field->name}->setTrackChanges(true);
		$page->{$field->name}->set($webmention->id, $webmention);
		$page->setOutputFormatting(false);

		if ( !$page->save($field->name, ['quiet' => true]) )
		{
			$this->log->save('webmentions-received', sprintf('There was an error saving webmention ID %d', $webmention->id));
			return false;
		}

		# clear the page cache
		$PageRender = $this->wire('modules')->get('PageRender');
		$cf = $PageRender->getCacheFile($page);

		if ( $cf->exists() )
		{
			$cf->remove();
		}

		return true;
	}

	/**
	 * This method handles incoming webmentions.
	 * Basic validations are performed, but the source URL is not parsed/verified.
	 * @access private
	 */
	private function receiveWebmention()
	{
		# TODO: Take into account the q= quality factor of Accept: headers.
		$http_accept = $_SERVER['HTTP_ACCEPT'];

		if ( $http_accept_override = $this->input->post('HTTP_ACCEPT') )
		{
			$http_accept = $http_accept_override;
		}

		if ( strpos($http_accept, 'application/json') !== false )
		{
			$content_type = 'application/json';
		}
		else if ( strpos($http_accept, 'text/plain') !== false )
		{
			$content_type = 'text/plain';
		}
		else
		{
			$content_type = 'text/html';
		}

		$is_www_form_urlencoded = strpos($_SERVER['CONTENT_TYPE'], 'application/x-www-form-urlencoded');

		# request is the correct content-type
		if ( $is_www_form_urlencoded !== false )
		{
			$source = $this->input->post('source');
			$target = $this->input->post('target');
			$vouch = $this->input->post('vouch');
			$source_sanitized = filter_var($source, FILTER_VALIDATE_URL);
			$target_sanitized = filter_var($target, FILTER_VALIDATE_URL);
			$vouch_sanitized = filter_var($vouch, FILTER_VALIDATE_URL);

			# source is missing
			if ( empty($source) )
			{
				$message = 'Webmention “source” parameter is missing.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			}

			# source is not a valid URL
			if ( empty($source_sanitized) )
			{
				$message = 'Webmention “source” parameter is not a valid URL.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			}

			# target is missing
			if ( empty($target) )
			{
				$message = 'Webmention “target” parameter is missing.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			}

			# target is not a valid URL
			if ( empty($target_sanitized) )
			{
				$message = 'Webmention “target” parameter is not a valid URL.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			}

			# source equals target
			if ( $source_sanitized == $target_sanitized )
			{
				$message = 'Webmention “source” and “target” parameters cannot be the same URL.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			}

			# vouch is required and missing
			if ( $this->is_vouch_required && empty($vouch) )
			{
				$message = 'Webmention “vouch” parameter is required.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(449, $content_type, $message);
			}

			# vouch supplied, but is not a valid url
			if ( $vouch && empty($vouch_sanitized) )
			{
				$message = 'Webmention “vouch” parameter is is not a valid URL.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(449, $content_type, $message);
			}

			if ( strtolower(parse_url($target, PHP_URL_HOST)) !== strtolower($this->config->httpHost) )
			{
				$message = 'Webmention “target” hostname is not valid.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			}

			$path = preg_replace('#' . $this->config->urls->root . '#', '/', parse_url($target, PHP_URL_PATH));
			$page = $this->pages->get($path);

			if ( $page instanceof NullPage )
			{
				$message = 'Webmention “target” is not a valid URL at this domain.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			}

			$target = $page->httpUrl;

			$this->findFieldtypeWebmentions($page);

			# no FieldtypeWebmention field on the target page; does not accept webmentions
			if ( empty($this->webmention_field) )
			{
				$message = 'Webmention “target” does not accept webmentions.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			}

			# vouch not accepted
			if ( $this->is_vouch_required && !$this->verifyReceivedVouch($vouch, $source) )
			{
				$message = 'Webmention “vouch” was not accepted.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			}

			$http = new WireHttp();
			$WebmentionField = $this->webmention_field->name;

			# Check source URL for redirects
			$response = $http->status($source);

			if ( $response )
			{
				$http_headers = $http->getResponseHeaders();

				# redirected; update final URL
				if ( !empty($http_headers['location']) )
				{
					$location = array_pop($http_headers['location']);
					$source = Mf2\resolveUrl($source, $location);
				}

			}

			# Check target URL for redirects
			$response = $http->status($target);

			if ( $response )
			{
				$http_headers = $http->getResponseHeaders();

				# redirected; update final URL
				if ( !empty($http_headers['location']) )
				{
					$location = array_pop($http_headers['location']);
					$target = Mf2\resolveUrl($target, $location);
				}

			}

			$md5key = md5($source . $target);
			$item = $page->{$WebmentionField}->get('md5key=' . $md5key);

			# update existing webmention
			if ( $item )
			{

				if ( $item->status != WebmentionItem::statusPending )
				{
					$page->$WebmentionField->setTrackChanges(true);

					$new_item = $item;
					$this->processWebmention($new_item);

					$page->$WebmentionField->replace($item, $new_item);
				}

			}
			# add new webmention
			else
			{
				$webmention = new WebmentionItem();

				$webmention->set('md5key', $md5key);
				$webmention->set('source_url', $source);
				$webmention->set('target_url', $target);
				$webmention->set('vouch_url', $vouch);
				$webmention->set('status', WebmentionItem::statusPending);
				$webmention->set('visibility', WebmentionItem::visibilityPublic);
				$webmention->set('created', date('Y-m-d H:i:s'));

				$page->$WebmentionField->add($webmention);
			}

			$outputFormatting = $page->outputFormatting;
			$page->setOutputFormatting(false);

			$page->save($WebmentionField, ['quiet' => true]);
			$page->setOutputFormatting($outputFormatting);

			$message = sprintf('Webmention from %s queued for processing.', parse_url($source, PHP_URL_HOST));

			if ( $this->verbose_logging )
			{
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
			}

			$this->httpResponse(202, $content_type, $message);
		}
		# incorrect content-type
		else
		{
			$message = 'Webmention must be posted with Content-Type: application/x-www-form-urlencoded.';
			$this->log->save('webmentions-received',
				sprintf('%s|%s|%s',
					$message,
					$_SERVER['REMOTE_ADDR'],
					''
				)
			);
			$this->httpResponse(400, $content_type, $message);
		}

		$message = 'An unexpected error occurred.';
		$this->log->save('webmentions-received',
			sprintf('%s|%s|%s',
				$message,
				$_SERVER['REMOTE_ADDR'],
				http_build_query($this->input->post->getArray())
			)
		);
		$this->httpResponse(500, $content_type, $message);
	}

	/**
	 * This method returns an array of URLs webmentions were sent to for a page ID
	 * @param int $page_id
	 * @access public
	 * @return array
	 */
	public function getWebmentionURLs($page_id)
	{
		$statement = $this->database->prepare("SELECT target FROM {$this->className}_send_queue WHERE pages_id = ? ORDER BY created ASC");
		$result = $statement->execute([$page_id]);

		if ( $result === false || $statement->rowCount() == 0 )
		{
			return [];
		}

		$urls = [];

		# each webmention to send
		while ( $row = $statement->fetch(PDO::FETCH_ASSOC) )
		{
			$urls[] = $row['target'];
		}

		return $urls;
	}

	/**
	 * This method adds URLs to a queue for asynchronous webmention sending
	 * @param array $urls
	 * @param string $source_url
	 * @param int $page_id
	 * @param array $params
	 * @access public
	 * @return bool
	 */
	public function queueWebmentions($urls, $source_url, $page_id, $params = [])
	{
		$unique_urls = array_unique($urls);
		$source = $this->sanitizer->url($source_url);
		$json_params = '';

		if ( $params )
		{
			$json_params = json_encode($params);
		}

		$statement = $this->database->prepare("INSERT INTO {$this->className}_send_queue SET pages_id = ?, source = ?, target = ?, params = ?, created = NOW(), modified = NOW()");

		foreach ( $unique_urls as $url )
		{
			$target = $this->sanitizer->url($url);

			# only queue webmention is source and target exist
			if ( $source && $target )
			{
				$result = $statement->execute([$page_id, $source, $target, $json_params]);
			}

		}

		return true;
	}

	/**
	 * This method initiates sending queued webmentions
	 * @access public
	 */
	public function sendWebmentions()
	{
		# fetch webmentions to be sent
		$result = $this->database->query("SELECT * FROM {$this->className}_send_queue WHERE processed IS NULL ORDER BY created ASC LIMIT 5");

		if ( $result === false || $result->rowCount() == 0 )
		{
			return;
		}

		$statement_processed = $this->database->prepare("UPDATE {$this->className}_send_queue SET processed = NOW() WHERE id = ?");

		# array of webmention responses
		$responses = [];

		# each webmention to send
		while ( $row = $result->fetch(PDO::FETCH_ASSOC) )
		{
			$extra_parameters =
			$params = [];

			if ( $row['params'] )
			{
				$params = json_decode($row['params'], true);
			}

			$responses[] = $this->sendWebmention($row['source'], $row['target'], $extra_parameters);

			$result_processed = $statement_processed->execute([$row['id']]);
		}

		return $responses;
	}

	/**
	 * This method sends an individual webmention
	 * @param string $source
	 * @param string $target
	 * @param array $extra_parameters
	 * @access public
	 */
	public function sendWebmention($source, $target, $extra_parameters = [])
	{
		$http = new WireHttp();

		$endpoint_data = null;

		# URL starts with http:// or https://
		if ( strpos($target, 'http://') === 0 || strpos($target, 'https://') === 0 )
		{
			$endpoint_data = $this->discovery($target);
		}

		# no endpoint found
		if ( !$endpoint_data )
		{

			if ( $this->verbose_logging )
			{
				$this->log->save('webmentions-sent', sprintf('No endpoint found for %s.', $target));
			}

			return null;
		}

		# vouch available for this target
		if ( $vouch = $this->findVouchFor($target) )
		{
			$extra_parameters['vouch'] = $vouch;
		}

		$endpoint = $endpoint_data['endpoint'];

		# endpoint is a loopback
		if ( $this->isLoopback($endpoint) )
		{
			$this->log->save('webmentions-sent', sprintf('Endpoint %s is localhost or a loopback address. Skipping.', $endpoint));
			return false;
		}

		# sending pingback as fallback
		if ( $endpoint_data['type'] == 'pingback' )
		{
			$data = xmlrpc_encode_request('pingback.ping', [$source, $target], ['verbosity' => 'no_white_space', 'encoding' => 'utf-8']);

			$http->setHeader('Content-Type', 'application/xml');
		}
		# sending webmention
		else
		{
			$data = array_merge(
				compact('source', 'target'),
				$extra_parameters
			);

			$http->setHeader('Accept', 'application/json, application/xml, text/html');
		}

		if ( $this->verbose_logging )
		{
			$this->log->save('webmentions-sent', sprintf('Initiate sending %s from %s to %s.', $endpoint_data['type'], $source, $target));
		}

		$response = $http->post($endpoint, $data);
		$http_code = $http->getHttpCode();
		$http_code_class = substr($http_code, 0, 1);

		# 2xx and 3xx HTTP responses considered successful
		if ( in_array($http_code_class, [2, 3]) )
		{
			$message = sprintf('Sent webmention for %s successfully to %s.', $target, $endpoint);
		}
		# error
		else
		{
			$message = sprintf('Error sending webmention for %s to %s. Response was HTTP %s', $target, $endpoint, $http_code);
		}

		$this->log->save('webmentions-sent', sprintf('%s|%s|%s|%s', $message, $http_code, http_build_query($data), $response));

		return $response;
	}

	/**
	 * This method handles extracting URLs from the supplied text
	 * @param string $text
	 * @param string $url
	 * @access protected
	 * @return array
	 */
	protected function extractURLs($text, $url)
	{
		$response = [];

		# regex pattern to match URLs
		$pattern_absolute = "~\b(?:https?://)[\w-]*[a-z][\w-]*(?:\.[\w-]+)+(?:/[\w\./%+?=&(amp;)?#\~-]+)?\b~i";
		$pattern_relative = '#(?<=href=(?:"|\')|href=)(?!https?|mailto)[^"\']+(?=(?:"|\'|>))#U';

		# match all URLs in the text
		preg_match_all($pattern_absolute, $text, $matches_absolute, PREG_SET_ORDER);
		preg_match_all($pattern_relative, $text, $matches_relative, PREG_SET_ORDER);

		# make all relative URLs absolute
		array_walk_recursive($matches_relative, [$this, 'resolveUrl'], $url);

		$matches = array_merge($matches_absolute, $matches_relative);

		foreach ( $matches as $match )
		{
			$response[] = reset($match);
		}

		$response = array_unique($response);

		return $response;
	}

	/**
	 * This method builds a relative URL
	 * @param string $url
	 * @access protected
	 * @return string
	 */
	protected function buildRelativeURL($url)
	{
		$relative = '';
		$relative .= parse_url($url, PHP_URL_PATH);
		$relative .= ( $query = parse_url($url, PHP_URL_QUERY) ) ? '?' . $query : '';
		$relative .= ( $fragment = parse_url($url, PHP_URL_FRAGMENT) ) ? '#' . $fragment : '';

		return $relative;
	}

	/**
	 * This method is a shortcut to Mf2\resolveUrl()
	 * @param array
	 * @access protected
	 * @return string
	 */
	protected function resolveUrl(&$path, $key, $url_base)
	{
		$path = Mf2\resolveUrl($url_base, $path);

		return $path;
	}

	/**
	 * This method resolves a URL's 3xx redirects and returns the final URL
	 * @param string $url
	 * @return string
	 */
	protected function resolveRedirects($url)
	{
		$http = new WireHttp();

		$response = $http->get($url);
		$http_headers = $http->getResponseHeaders();

		# redirected; update final URL
		if ( !empty($http_headers['location']) )
		{
			$url = $http_headers['location'];
		}

		return $url;
	}

	/**
	 * This method handles discovery of webmention endpoint
	 * @param string $url
	 * @access protected
	 * @return string
	 */
	protected function discovery($url)
	{
		$headers = $this->fetchHead($url);

		## 1. Look for Link: header with webmention rel-value

		# link headers
		if ( !empty($headers['link']) )
		{

			if ( !is_array($headers['link']) )
			{

				if ( strpos($headers['link'], ',') )
				{
					$temp_links = explode(',', $headers['link']);
					$headers['link'] = array_map('trim', $temp_links);
				}
				else
				{
					$headers['link'] = [$headers['link']];
				}

			}

			foreach ( $headers['link'] as $header )
			{
				# match rel=webmention link header
				preg_match('#\<(.*?)\>\s*\;\s*rel\=\"?(?:.*?)webmention(?:.*?)\"?#', $header, $matches);

				# rel=webmention link header found
				if ( count($matches) == 2 )
				{
					$endpoint = \Mf2\resolveUrl($url, array_pop($matches));

					return [
						'type'		=> 'webmention',
						'endpoint'	=> $this->resolveRedirects($endpoint)
					];
				}

			}

		}

		## 2. Look for <link> elements with webmention rel-value

		$links = $this->fetchLinkElements($url);

		# webmention <link> element found
		if ( !empty($links['webmention']) )
		{
			$endpoint = \Mf2\resolveUrl($url, reset($links['webmention']));

			return [
				'type'		=> 'webmention',
				'endpoint'	=> $this->resolveRedirects($endpoint)
			];
		}

		## 3. Look for X-Pingback: header

		# X-Pingback: header found
		if ( !empty($headers['pingback']) )
		{
			return [
				'type'		=> 'pingback',
				'endpoint'	=> reset($headers['pingback'])
			];
		}

		## 4. Look for <link> elements with pingback rel-value

		# pingback <link> element found
		if ( !empty($links['pingback']) )
		{
			return [
				'type'		=> 'pingback',
				'endpoint'	=> reset($links['pingback'])
			];
		}

		return null;
	}

	/**
	 * This method determines if a URL is is a loopback
	 * @param string $url
	 * @access public
	 * @return bool
	 */
	public function isLoopback($url)
	{
		$domain = parse_url($url, PHP_URL_HOST);

		if ( $domain == 'localhost' )
		{
			return true;
		}

		$records = dns_get_record($domain);
		$ips = [];

		# each DNS record
		foreach ( $records as $record )
		{

			# host matches and the record is A or AAAA
			if ( $record['host'] == $domain && in_array($record['type'], ['A', 'AAAA']) )
			{
				$ip = ( $record['type'] == 'A' ) ? $record['ip'] : $record['ipv6'];

				# the IP address is in the reserved range, this is a loopback
				if ( filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_RES_RANGE) === false )
				{
					return true;
				}

			}

		}

		return false;
	}

	/**
	 * This method fetches the body of a URL
	 * @param string $url
	 * @access protected
	 */
	protected function fetchBody($url)
	{
		$http = new WireHttp();

		$response = $http->get($url);

		if ( !$response )
		{
			return '';
		}

		return $response;
	}

	/**
	 * This method performs a HEAD request and returns an array of headers
	 * @param string $url
	 * @access protected
	 */
	protected function fetchHead($url)
	{
		$http = new ProcessWireShim\WireHttp();

		$return_headers = [
			'link'		=> [],
			'pingback'	=> []
		];

		$response = $http->status($url);

		if ( !$response )
		{
			return $return_headers;
		}

		$http_headers = $http->getResponseHeaders();

		return array_intersect_key($http_headers, $return_headers);
	}

	/**
	 * This method parses the <link> elements from HTML
	 * @param string $url
	 * @access protected
	 * @return array
	 */
	protected function fetchLinkElements($url)
	{
		$links = [];

		$body = $this->fetchBody($url);

		if ( !$body )
		{
			return $links;
		}

		libxml_use_internal_errors(true);
		$dom = new DOMDocument('1.0', 'UTF-8');
		$dom->loadHTML($body);
		$dom->preserveWhiteSpace = false;

		$element_types = ['a', 'link'];

		# each type of element
		foreach ( $element_types as $element )
		{
			# get the DOMNodeList of links
			$link_elements = $dom->getElementsByTagName($element);

			# each DOMElement
			foreach ( $link_elements as $link )
			{
				$rel = $link->getAttribute('rel');
				$href = $link->getAttribute('href');
				$rels = explode(' ', $rel);

				foreach ( $rels as $temp_rel )
				{
					$rel = trim($temp_rel);

					if ( empty($links[$rel]) )
					{
						$links[$rel] = [$href];
					}
					else
					{
						$links[$rel][] = $href;
					}

				}

			}

		}

		return $links;
	}

	/**
	 * This method handles sending an HTTP response
	 * @param int $http_response_code
	 * @param string $content_type
	 * @param string $message
	 * @access private
	 */
	private function httpResponse($http_response_code, $content_type, $message)
	{

		switch ( $content_type )
		{
			case 'application/json':
				$body = json_encode(['message' => $message]);
			break;

			case 'text/plain':
				$body = $message;
			break;

			default:
			case 'text/html':
				$body = <<< END
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8"/>
	<title>Webmention Response: {$http_response_code}</title>
</head>

<body>
	<p> {$message} </p>
</body>

</html>
END;
			break;
		}

		$content_header = sprintf('Content-Type: %s; charset=utf8', $content_type);

		header($content_header);

		if ( function_exists('http_response_code') )
		{
			http_response_code($http_response_code);
		}
		else if ( $text = $this->http_response_codes[$http_response_code] )
		{
			$protocol = ( isset($_SERVER['SERVER_PROTOCOL']) ) ? $_SERVER['SERVER_PROTOCOL'] : 'HTTP/1.0';
			header($protocol . ' ' . $http_response_code . ' ' . $text);
		}

		echo $body;
		exit;
	}

	/**
	 * This method retrieves microformat content from HTML
	 * Returns false if no microformats found in the HTML
	 * @param string $html
	 * @param string $url
	 * @access public
	 * @return mixed
	 */
	public function fetchMicroformats($html, $url)
	{
		# parse the content for microformats
		$parsed = Mf2\parse($html, $url);

		# parsed content is microformat collection
		if ( Mf2helper\isMicroformatCollection($parsed) )
		{
			return $parsed;
		}
		#
		else
		{
			return false;
		}
	}

	/**
	 * This method handles parsing the first h-entry in a microformat collection
	 * Returns false if no h-entry found in the collection
	 * @param array $collection
	 * @param WebmentionItem $webmention
	 * @access public
	 * @return mixed
	 */
	public function parseFirstEntry($collection, WebmentionItem &$webmention)
	{
		# find h-entry in collection
		$entries = Mf2helper\findMicroformatsByType($collection, 'h-entry');

		# one or more h-entry found
		if ( $entries )
		{
			$entry = reset($entries);

			$in_reply_to = [];
			$target_url = $webmention->target_url;

			# in-reply-to found
			if ( !empty($entry['properties']['in-reply-to']) && is_array($entry['properties']['in-reply-to']) )
			{

				foreach ( $entry['properties']['in-reply-to'] as $item )
				{

					if ( is_array($item) )
					{
						$in_reply_to[] = Mf2helper\getPlaintext($item, 'url');
					}
					else if ( is_string($item) )
					{
						$in_reply_to[] = $item;
					}

				}

			}

			# set type to 'reply' if in-reply-to matches the target; otherwise 'mention'
			$type = ( in_array($target_url, $in_reply_to) ) ? 'reply' : 'mention';
			$webmention->set('type', $type);

			$like_of = Mf2helper\getPlaintextArray($entry, 'like-of');
			$repost_of = Mf2helper\getPlaintextArray($entry, 'repost-of');
			$rsvp = Mf2helper\getPlaintext($entry, 'rsvp');

			# if like-of matches target, set the flag
			if ( $like_of && in_array($target_url, $like_of) )
			{
				$webmention->set('is_like', 1);
			}

			# if repost-of matches target, set the flag
			if ( $repost_of && in_array($target_url, $repost_of) )
			{
				$webmention->set('is_repost', 1);
			}

			# rsvp
			if ( $rsvp )
			{
				$webmention->set('is_rsvp', 1);
			}

			$webmention->set('name', Mf2helper\getPlaintext($entry, 'name'));
			$webmention->set('content', Mf2helper\getHtml($entry, 'content'));
			$webmention->set('content_plain', Mf2helper\getPlaintext($entry, 'content'));

			if ( $url = Mf2helper\getPlaintext($entry, 'url') )
			{
				$webmention->set('url', $url);
			}

			$published = Mf2helper\getDateTimeProperty('published', $entry, true);
			$array_date = $this->parseDateTime($published, $webmention->created);
			$webmention->set('published', $array_date['date']);
			$webmention->set('published_offset', $array_date['has_timezone']);

			$updated = Mf2helper\getDateTimeProperty('updated', $entry, true);
			$array_date = $this->parseDateTime($updated, $webmention->created);
			$webmention->set('updated', $array_date['date']);
			$webmention->set('updated_offset', $array_date['has_timezone']);

			return $entry;
		}
		# no h-entry found
		else
		{
			$webmention->set('url', $webmention->source_url);
			$webmention->published = $webmention->updated = null;
			return false;
		}
	}

	/**
	 * This method handles parsing the first h-card in a microformat collection
	 * Returns false if no h-card found in the collection
	 * @param array $collection
	 * @param WebmentionItem $webmention
	 * @access private
	 * @return mixed
	 */
	private function parseFirstCard($collection, WebmentionItem &$webmention)
	{
		# find h-card in collection
		$cards = Mf2helper\findMicroformatsByType($collection, 'h-card');

		# one or more h-card found
		if ( $cards )
		{
			$card = reset($cards);

			$webmention->set('author_name', Mf2helper\getPlaintext($card, 'name'));
			$webmention->set('author_photo', Mf2helper\getPlaintext($card, 'photo'));
			$webmention->set('author_logo', Mf2helper\getPlaintext($card, 'logo'));
			$webmention->set('author_url', reset(Mf2helper\getPlaintextArray($card, 'url')));

			return true;
		}
		# no h-card found
		else
		{
			return false;
		}
	}

	/**
	 * This method performs the authorship algorithm
	 * @param array $entry
	 * @param array $mf2
	 * @param WebmentionItem $webmention
	 * @access public
	 * @return bool
	 */
	public function getAuthorship($entry, $mf2, WebmentionItem &$webmention)
	{
		$author = '';
		$author_page = '';

		# author property
		if ( Mf2helper\hasProp($entry, 'author') )
		{
			$author = Mf2helper\getAuthor($entry);
		}
		# check h-feed for author property
		else
		{
			# TODO: authorship step 4. Not sure it's pertinent to this plugin, though.
		}

		# author property
		if ( $author )
		{

			# author h-card found
			if ( Mf2helper\isMicroformat($author) )
			{
				return $this->setAuthor($author, $webmention);
			}
			# author value is a URL
			else if ( filter_var($author, FILTER_VALIDATE_URL) )
			{
				$author_page = $author;
			}
			# author value is the author's name
			else
			{
				$webmention->set('author_name', $author);
				return true;
			}

		}

		# no author_page set yet; rel-author exists
		if ( !$author_page && !empty($mf2['rels']['author']) )
		{
			$author_page = reset($mf2['rels']['author']);
		}

		# parse author_page
		if ( $author_page )
		{
			$http = new WireHttp();

			$response = $http->get($author_page);
			$mf2_author_page = $this->fetchMicroformats($response, $author_page);

			# no microformats
			if ( $mf2_author_page === false )
			{
				return false;
			}

			$cards = Mf2helper\findMicroformatsByType($mf2_author_page, 'h-card');

			# each h-card (reference authorship step 7.2)
			foreach ( $cards as $card )
			{
				$u_url = Mf2helper\getPlaintext($card, 'url');
				$u_uid = Mf2helper\getPlaintext($card, 'uid');

				# author found
				if ( $u_url == $u_uid && $u_uid == $author_page )
				{
					return $this->setAuthor($card, $webmention, $u_url);
				}

			}

			# rel-mes on original page (reference authorship step 7.3)
			if ( !empty($mf2_author_page['rels']['me']) )
			{

				# each h-card
				foreach ( $cards as $card )
				{
					$u_url = Mf2helper\getPlaintext($card, 'url');

					# author found
					if ( in_array($u_url, $mf2_author_page['rels']['me']) )
					{
						return $this->setAuthor($card, $webmention, $u_url);
					}

				}

			}

			## reference authorship step 7.4

			# h-cards on the original h-entry's page
			$cards = Mf2helper\findMicroformatsByType($mf2, 'h-card');

			# each h-card
			foreach ( $cards as $card )
			{
				$u_url = Mf2helper\getPlaintext($card, 'url');

				# author found
				if ( $u_url == $author_page )
				{
					return $this->setAuthor($card, $webmention, $u_url);
				}

			}

		}

		return false;
	}

	/**
	 * This method sets the Webmention's author information from the supplied h-card
	 * @param array $card: parsed mf2 h-card
	 * @param WebmentionItem $webmention
	 * @param string $author_url
	 * @access protected
	 * @return bool
	 */
	protected function setAuthor($card, WebmentionItem &$webmention, $author_url = '')
	{
		$webmention->set('author_name', Mf2helper\getPlaintext($card, 'name'));
		$webmention->set('author_photo', $this->cacheImage(Mf2helper\getPlaintext($card, 'photo')) );
		$webmention->set('author_logo', $this->cacheImage(Mf2helper\getPlaintext($card, 'logo')) );

		if ( $author_url )
		{
			$webmention->set('author_url', $author_url);
		}
		else
		{
			$author_urls = Mf2helper\getPlaintextArray($card, 'url');
			$webmention->set('author_url', reset($author_urls));
		}

		return true;
	}

	/**
	 * This method is hookable for caching images.
	 * By default it does nothing, returning the supplied URL.
	 * @param string $url
	 * @access public
	 * @return string
	 */
	public function ___cacheImage($url)
	{
		return $url;
	}

	/**
	 * DEPRECATED. See method getAuthorship()
	 * This method handles parsing the first rel-author on a page
	 * @param array $context
	 * @param WebmentionItem $webmention
	 * @access private
	 * @return mixed
	 */
	private function parseRelAuthor($context, WebmentionItem &$webmention)
	{

		# rel-author in parsed content
		if ( !empty($context['rels']['author']) )
		{
			$url = reset($context['rels']['author']);

			# microformat(s) found at rel-author URL
			if ( $parsed_content = $this->fetchMicroformats($url) )
			{
				# parse the first h-card, if any
				return $this->parseFirstCard($parsed_content, $webmention);
			}

		}
		# no rel-author
		else
		{
			return false;
		}
	}

	/**
	 * This method handles parsing the default author information using the source URL
	 * @param string $url
	 * @param WebmentionItem $webmention
	 * @access private
	 */
	private function parseDefaultAuthor($url, WebmentionItem &$webmention)
	{
		$url_parts = parse_url($url);

		$webmention->set('author_name', $url_parts['host']);
		$webmention->set('author_url', sprintf('%s://%s', $url_parts['scheme'], $url_parts['host']));

		return true;
	}

	/**
	 * This method handles parsing a date string into Y-m-d H:i:s format, UTC timezone
	 * @param string $string_date
	 * @param string $fallback
	 * @access private
	 * @return mixed
	 */
	private function parseDateTime($string_date, $fallback = null)
	{
		$timezone = null;
		$parsed = date_parse($string_date);
		$has_timezone = ( isset($parsed['zone']) ) ? true : false;

		if ( empty($string_date) && !empty($fallback) )
		{
			$string_date = $fallback;
		}

		try
		{

			# datetime string has timezone
			if ( $has_timezone )
			{
				$date = new DateTime($string_date);
				$timezone = $date->getTimezone()->getName();

				# date is not in ProcessWire timezone; convert
				if ( $timezone != $this->gmt_offset )
				{
					$timezone = new DateTimeZone($this->config->timezone);
					$date->setTimezone($timezone);
				}

			}
			#
			else
			{
				$date = new DateTime($string_date);
			}

		}
		# catch: silent error; use the current datetime
		catch ( Exception $e )
		{
			$date = new DateTime($fallback);
		}

		return [
			'has_timezone'	=> $has_timezone,
			'timezone' => $timezone,
			'date'			=> $date->format('Y-m-d H:i:s')
		];
	}

	/**
	 * This method records HTTP referers, to be processed as potential vouches
	 * @param string $referer
	 * @access public
	 * @return mixed
	 */
	public function recordReferer($referer = '')
	{

		# no referer to record
		if ( empty($_SERVER['HTTP_REFERER']) )
		{
			return;
		}

		$referer = $_SERVER['HTTP_REFERER'];

		# do not track internal referers
		if ( parse_url($referer, PHP_URL_HOST) == $this->config->httpHost )
		{
			return;
		}

		$trimmed_referer = trim(str_replace(['http://', 'https://'], '', $referer), '/');

		# do not track referers from a homepage; expectation is that content changes periodically.
		if ( parse_url($referer, PHP_URL_HOST) == $trimmed_referer )
		{
			return;
		}

		$referer = $this->sanitizer->url($referer);

		$statement = $this->database->prepare("SELECT * FROM {$this->className}_vouches WHERE url = ?");
		$result = $statement->execute([$referer]);

		if ( $result === false || $statement->rowCount() > 0 )
		{
			return;
		}

		$statement = $this->database->prepare("INSERT INTO {$this->className}_referer_queue SET url = ?, created = NOW(), modified = NOW() ON DUPLICATE KEY UPDATE modified = NOW()");
		$result = $statement->execute([$referer]);

		return;
	}

	/**
	 * This method handles processing referers to determine if they can be used as a vouch
	 * @access public
	 * @return mixed
	 */
	public function processReferer()
	{
		set_time_limit(0);

		$result = $this->database->query("SELECT * FROM {$this->className}_referer_queue WHERE processed IS NULL ORDER BY created ASC LIMIT 1");

		if ( $result === false || $result->rowCount() == 0 )
		{
			return;
		}

		$row = $result->fetch(PDO::FETCH_ASSOC);

		$statement_processed = $this->database->prepare("UPDATE {$this->className}_referer_queue SET processed = NOW() WHERE id = ?");

		$http = new WireHttp();;
		$response = $http->get( $this->sanitizer->url($row['url']) );
		$http_code = $http->getHttpCode();

		# referer URL is HTTP 200 OK
		if ( $http_code == 200 )
		{
			libxml_use_internal_errors(true);
			$dom = new DOMDocument('1.0', 'UTF-8');
			$dom->loadHTML($response);
			$dom->preserveWhiteSpace = false;

			# get <a> DOMElements
			$a_elements = $dom->getElementsByTagName('a');

			$statement_vouches = $this->database->prepare("INSERT INTO {$this->className}_vouches SET domain = ?, url = ?, created = NOW(), modified = NOW() ON DUPLICATE KEY UPDATE modified = NOW()");

			$ignore_domains = [
				'brid.gy',
				'google.com',
				'yahoo.com',
				'bing.com',
				't.co',
			];

			# each <a> DOMElement
			foreach ( $a_elements as $a )
			{
				$rel = $a->getAttribute('rel');
				$href = $a->getAttribute('href');

				$domain = preg_replace('#^www\.(.+\.)#i', '$1', parse_url($row['url'], PHP_URL_HOST));

				# domain is not ignored, link does not have rel=nofollow, and links back
				if ( !in_array($domain, $ignore_domains) && ($rel != 'nofollow') && strpos($href, $this->config->httpHost) !== false )
				{
					$url = $this->sanitizer->url($row['url']);
					$statement_vouches->execute([$domain, $url]);

					break;
				}

			}

		}
		# non-200 response
		else
		{

			if ( $this->verbose_logging )
			{
				$this->log->save('webmentions-referers', sprintf('Referer URL %s returned HTTP %s', $row['url'], $http_code));
			}

		}

		$statement_processed->execute([$row['id']]);

		return;
	}

	/**
	 * This method verifies a received vouch URL
	 * @param string $vouch_url
	 * @param string $source_url
	 * @access public
	 * @see https://indieweb.org/Vouch
	 */
	public function verifyReceivedVouch($vouch_url, $source_url)
	{
		$http = new WireHttp();

		$approved_vouches = explode("\n", $this->approved_vouches);
		$approved_vouches = array_map('trim', $approved_vouches);

		$vouch_domain = parse_url($vouch_url, PHP_URL_HOST);
		$source_domain = parse_url($source_url, PHP_URL_HOST);
		$source_base_url = parse_url($source_url, PHP_URL_SCHEME) . '://' . $source_domain;

		# vouch domain is not accepted
		if ( !in_array($vouch_domain, $approved_vouches) )
		{
			$this->log->save('webmentions-received', sprintf('Vouch domain %s not approved.', $vouch_domain));
			return false;
		}

		set_time_limit(0);

		$response = $http->get($vouch_url);

		libxml_use_internal_errors(true);
		$dom = new DOMDocument('1.0', 'UTF-8');
		$dom->loadHTML($response);
		$dom->preserveWhiteSpace = false;

		# get <a> DOMElements
		$a_elements = $dom->getElementsByTagName('a');

		# each <a> DOMElement
		foreach ( $a_elements as $a )
		{
			$rel = $a->getAttribute('rel');
			$href = $a->getAttribute('href');

			# vouch URL links to source domain and does *not* have rel=nofollow
			if ( strpos($href, $source_domain) !== false && ($rel != 'nofollow') )
			{
				return true;
			}

		}

		$this->log->save('webmentions-received', sprintf('Vouch %s does not link to %s with rel=nofollow.', $vouch_url, $source_domain));
		return false;
	}

	/**
	 * This method attempts to find a vouch URL for sending webmentions
	 * @param string $url
	 * @access public
	 * @return bool|string
	 * @see https://indieweb.org/Vouch
	 */
	public function findVouchFor($url)
	{
		$domain = preg_replace('#^www\.(.+\.)#i', '$1', parse_url($url, PHP_URL_HOST));

		$ignore_domains = [
			$this->config->httpHost,
			'brid.gy',
			'google.com',
			'yahoo.com',
			'bing.com',
			't.co',
		];

		# ignore vouch for this domain
		if ( in_array($domain, $ignore_domains) )
		{
			return false;
		}

		$http = new WireHttp();

		$checked_domains = [];

		$domain = parse_url($url, PHP_URL_HOST);
		$base_url = parse_url($url, PHP_URL_SCHEME) . '://' . $domain;

		# First check if this domain is in the vouches table (they already link to us); if so, use that for vouch
		$result = $this->database->query("SELECT * FROM {$this->className}_vouches WHERE domain = '{$domain}' AND `deleted` IS NULL");

		# db/query error
		if ( $result === false )
		{
			return false;
		}
		# vouch found
		else if ( $result->rowCount() > 0 )
		{
			$row = $result->fetch(PDO::FETCH_ASSOC);
			return $row['url'];
		}

		$response = $http->get($url);

		libxml_use_internal_errors(true);
		$dom = new DOMDocument('1.0', 'UTF-8');
		$dom->loadHTML($response);
		$dom->preserveWhiteSpace = false;

		# get <a> DOMElements
		$a_elements = $dom->getElementsByTagName('a');

		# each <a> DOMElement
		foreach ( $a_elements as $a )
		{
			$rel = $a->getAttribute('rel');
			$href = $a->getAttribute('href');

			# link does not have rel=nofollow
			if ( ($rel != 'nofollow') )
			{
				$full_url = Mf2\resolveUrl($base_url, $href);
				$potential_vouch_domain = parse_url($full_url, PHP_URL_HOST);

				# link is external and domain has not already been checked
				if ( $potential_vouch_domain != $domain && !in_array($potential_vouch_domain, $checked_domains) )
				{
					$checked_domains[] = $potential_vouch_domain;

					# check vouches
					$result = $this->database->query("SELECT * FROM {$this->className}_vouches WHERE domain = '{$potential_vouch_domain}'");

					if ( $result === false || $result->rowCount() == 0 )
					{
						continue;
					}

					$row = $result->fetch(PDO::FETCH_ASSOC);
					return $row['url'];
				}

			}

		}

		return false;
	}

	/**
	 * This method processes the vouch_whitelist URL and adds any new vouch domains found there
	 * @access protected
	 * @return bool
	 */
	protected function processVouchWhitelist()
	{

		if ( !$this->vouch_whitelist )
		{
			return false;
		}

		$has_new_domains = false;

		# retrieve the module's config data; break out approved vouch domains into array
		$data = $this->modules->getModuleConfigData($this);
		$approved_vouches = explode("\n", $data['approved_vouches']);

		# fetch the vouch_whitelist page
		$http = new WireHttp();
		$response = $http->get($this->vouch_whitelist);

		# microformats collection
		if ( $collection = $this->fetchMicroformats($response, $this->vouch_whitelist) )
		{
			$cards = Mf2helper\findMicroformatsByType($collection, 'h-card');

			# each h-card
			foreach ( $cards as $card )
			{
				$url = Mf2helper\getPlaintext($card, 'url');
				$domain = preg_replace('#^www\.(.+\.)#i', '$1', parse_url($url, PHP_URL_HOST));

				# domain is not in approved vouches yet; add it
				if ( !in_array($domain, $approved_vouches) )
				{
					$has_new_domains = true;
					$approved_vouches[] = $domain;
				}

			}

		}

		# need to update the config
		if ( $has_new_domains )
		{
			# alpha sort the domains, implode to a string, and save
			sort($approved_vouches);
			$data['approved_vouches'] = implode("\n", $approved_vouches);
			$this->modules->saveModuleConfigData($this, $data);
		}

		return true;
	}

	/**
	 * This method searches the FieldtypeWebmentions
	 * @param string $selector_string
	 * @access public
	 * @return WebmentionArray
	 */
	public function find($selector_string)
	{

		# webmention field already found
		if ( $this->webmention_field )
		{
			$field = $this->webmention_field;
		}
		# look for first webmention field
		else
		{

			# each field
			foreach ( $this->fields as $field )
			{

				# add FieldtypeWebmentions to $fields array
				if ( $field->type instanceof FieldtypeWebmentions )
				{
					break;
				}

			}

		}

		return $field->type->find($field, $selector_string);
	}

	/**
	 * Update database schema
	 *
	 * This method applies incremental updates until latest schema version is
	 * reached, while also keeping schema_version config setting up to date.
	 *
	 */
	private function updateDatabaseSchema()
	{

		#
		while ( $this->schema_version < self::SCHEMA_VERSION )
		{
			++$this->schema_version;

			switch ( $this->schema_version )
			{
				case 2:
					$sql = "ALTER TABLE {$this->className}_send_queue ADD pages_id INT(10) UNSIGNED NOT NULL DEFAULT 0 AFTER id";
				break;

				case 3:
					$sql = "ALTER TABLE {$this->className}_send_queue ADD params TEXT AFTER vouch ";
				break;

				default:
					throw new WireException("Unrecognized database schema version: $this->schema_version");
				break;
			}

			if ( $sql && $this->database->exec($sql) !== false )
			{
				$config_data = $this->modules->getModuleConfigData($this);
				$config_data['schema_version'] = $this->schema_version;
				$this->modules->saveModuleConfigData($this, $config_data);
			}
			else
			{
				throw new WireException("Couldn't update database schema to version $this->schema_version");
			}

		}

	}
}

