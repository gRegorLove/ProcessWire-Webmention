<?php namespace ProcessWire;
/**
 * Webmention module
 *
 * Provides webmention support for ProcessWire
 *
 * @author Gregor Morrill, https://gregorlove.com
 * @see https://webmention.net/
 */

use DateTime;
use DateTimeZone;
use DOMDocument;
use PDO;
use Mf2;
use BarnabyWalters\Mf2 as Mf2helper;
use GregorMorrill\ProcessWireShim;
use ProcessWire\LazyCron;


$dirname = dirname(__FILE__);
require_once($dirname . '/vendor/autoload.php');
require_once($dirname . '/GregorMorrill/Webmention/WireHttp.php');

class Webmention extends WireData implements Module, ConfigurableModule
{
	/**
	 * Reference to the Webmention Field object used by this module
	 * @var Field
	 * @access protected
	 */
	protected $webmention_field = NULL;


	/**
	 * HTTP response codes
	 * @var array
	 * @access protected
	 */
	protected $http_response_codes = array(
		200	=> 'OK',
		202	=> 'Accepted',
		400	=> 'Bad Request',
		404	=> 'Not Found',
		449 => 'Retry With',
		500	=> 'Internal Server Error',
	);


	/**
	 * Provide module information to ProcessWire
	 * @access public
	 * @return array
	 */
	public static function getModuleInfo()
	{
		return array(
			'title'		=> 'Webmention',
			'version'	=> 113,
			'summary'	=> 'Webmention is a simple way to automatically notify any URL when you link to it on your site. From the receiver’s perspective, it is a way to request notification when other sites link to it.',
			'href'		=> 'https://www.webmention.net',
			'singular'	=> TRUE,
			'autoload'	=> TRUE,
			'installs'	=> array('FieldtypeWebmentions', 'InputfieldWebmentions', 'ProcessWebmentionsManager'),
		);
	} # end method getModuleInfo()


	/**
	 * Current database schema for non-fieldtype database tables
	 * @var int SCHEMA_VERSION
	 */
	const SCHEMA_VERSION = 3;


	/**
	 * This method gets the module's default config data
	 * @access public
	 * @return array
	 */
	public static function getDefaultData()
	{
		return array(
			'fields_to_parse' => 'body',
			'http_https_same' => 1,
			'verbose_logging' => 1,
			'is_vouch_required' => 0,
			'schema_version' => self::SCHEMA_VERSION,
		);
	} # end method getDefaultData()


	/**
	 * This method handles setting up the module's configuration fields
	 * @param array $data
	 * @access public
	 * @return InputfieldWrapper
	 */
	public static function getModuleConfigInputFields(array $data)
	{
		$inputfields = new InputfieldWrapper();

		# frequencty to process received webmentions
		$field = wire('modules')->get('InputfieldSelect');
		$field->label = 'Frequency to automatically process received webmentions';
		$field->attr('name+id', 'frequency_to_process');
		$field->columnWidth = 50;

		$options = array(
			0 => 'Disabled',
			1 => '1 minute',
			2 => '2 minutes',
			3 => '3 minutes',
			4 => '4 minutes',
			5 => '5 minutes',
			10 => '10 minutes',
			15 => '15 minutes',
			30 => '30 minutes',
			45 => '45 minutes',
			60 => '60 minutes',
		);

		$field->addOptions($options);

		if ( isset($data['frequency_to_process']) )
		{
			$field->value = $data['frequency_to_process'];
		}
		else
		{
			$field->value = 0;
		}

		$inputfields->add($field);

		# ProcessWire fields to parse
		$field = wire('modules')->get('InputfieldText');
		$field->name = 'fields_to_parse';
		$field->label = 'Fields to parse for URLs';
		$field->description = 'Enter a comma-separated list of field names.';
		$field->columnWidth = 50;

		if ( isset($data['fields_to_parse']) )
		{
			$field->value = $data['fields_to_parse'];
		}
		else
		{
			$field->value = 'body';
		}

		$inputfields->add($field);

		# webmention custom endpoint
		$field = wire('modules')->get('InputfieldText');
		$field->name = 'custom_endpoint';
		$field->label = 'Custom webmention endpoint URL';
		$field->description = 'If your webmention endpoint is at a different URL, enter it here. Otherwise, leave blank.';
		$field->columnWidth = 50;

		if ( isset($data['custom_endpoint']) )
		{
			$field->value = $data['custom_endpoint'];
		}

		$inputfields->add($field);

		# Treat http and https incoming links the same
		$field = wire('modules')->get('InputfieldCheckbox');
		$field->name = 'http_https_same';
		$field->label = 'Treat http and https as the same';
		$field->checked = ( $data['http_https_same'] ) ? 'checked' : '';
		$field->description = 'Incoming links http://example.com and https://example.com are the same page';
		$field->columnWidth = 50;

		$inputfields->add($field);

		# Verbose logging
		$field = wire('modules')->get('InputfieldCheckbox');
		$field->name = 'verbose_logging';
		$field->label = 'Enable verbose logging';
		$field->checked = ( $data['verbose_logging'] ) ? 'checked' : '';
		$field->description = 'Verbose logging includes webmention endpoint discovery, sending, and recieving. Regular logging will only include errors.';
		$field->columnWidth = 50;

		$inputfields->add($field);

		# Require received webmentions include a Vouch URL
		$field = wire('modules')->get('InputfieldCheckbox');
		$field->name = 'is_vouch_required';
		$field->value = 0;
		$field->checked = ( $data['is_vouch_required'] ) ? 'checked' : '';
		$field->label = 'Require webmention with vouch';
		$field->description = 'Vouch is currently in beta.';
		$field->columnWidth = 50;

		$inputfields->add($field);

		# monitor for approved vouch domains
		$field = wire('modules')->get('InputfieldText');
		$field->name = 'vouch_whitelist';
		$field->label = 'Vouch whitelist URL';
		$field->description = 'You can enter the URL of your blogroll or other whitelist. It will be monitored periodically and new domains will be added to the list of approved vouch domains. No domains will be removed from the approved vouch domains.';
		$field->columnWidth = 50;

		if ( isset($data['vouch_whitelist']) )
		{
			$field->value = $data['vouch_whitelist'];
		}

		$inputfields->add($field);

		# Domains accepted as Vouch URLs
		$field = wire('modules')->get('InputfieldTextarea');
		$field->name = 'approved_vouches';
		$field->label = 'Approved vouch domains';
		$field->description = 'Enter domains you will accept as vouches.';
		$field->columnWidth = 50;

		if ( isset($data['approved_vouches']) )
		{
			$field->value = $data['approved_vouches'];
		}

		$inputfields->add($field);

		return $inputfields;
	} # end method getModuleConfigInputFields()


	/**
	 * Module constructor
	 * @access public
	 */
	public function __construct()
	{
		foreach ( self::getDefaultData() as $key => $value )
		{
			$this->$key = $value;
		}
	} # end method __construct()


	/**
	 * This method handles installing the module
	 * @access public
	 */
	public function ___install()
	{

		# if: webmention template does not exist yet
		if ( is_null($this->templates->get('webmention-endpoint')) )
		{
			# add a field group for the webmention endpoint template
			$fg = new Fieldgroup();
			$fg->name = 'webmention-endpoint';
			$fg->add($this->fields->get('title'));
			$fg->save();

			# add the webmention-endpoint template
			$t = new Template();
			$t->label = 'Webmention Endpoint';
			$t->name = 'webmention-endpoint';
			$t->filename = 'webmention-endpoint';
			$t->fieldgroup = $fg;
			$t->save();

			# add a page using the webmention-endpoint template
			$p = new Page();
			$p->template = 'webmention-endpoint';
			$p->parent = 1;
			$p->title = 'Webmention Endpoint';
			$p->save();
		} # end if

		# save the default module configuration
		$this->modules->saveModuleConfigData($this, self::getDefaultData());

		$sql = <<< END
CREATE TABLE `{$this->className}_send_queue` (
	`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
	`pages_id` int(10) unsigned NOT NULL DEFAULT '0',
	`source` varchar(255) NOT NULL DEFAULT '',
	`target` varchar(255) NOT NULL DEFAULT '',
	`vouch` varchar(255) NOT NULL DEFAULT '',
	`params` text,
	`created` datetime NOT NULL,
	`modified` datetime NOT NULL,
	`processed` datetime DEFAULT NULL,
	PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8
END;
		$this->database->query($sql);

		$sql = <<< END
CREATE TABLE `{$this->className}_referer_queue` (
	`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
	`url` varchar(255) NOT NULL DEFAULT '',
	`created` datetime NOT NULL,
	`modified` datetime NOT NULL,
	`processed` datetime DEFAULT NULL,
	PRIMARY KEY (`id`),
	UNIQUE KEY `url` (`url`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8
END;
		$this->database->query($sql);

		$sql = <<< END
CREATE TABLE `{$this->className}_vouches` (
	`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
	`domain` varchar(255) NOT NULL DEFAULT '',
	`url` varchar(255) NOT NULL DEFAULT '',
	`created` datetime NOT NULL,
	`modified` datetime NOT NULL,
	`deleted` datetime DEFAULT NULL,
	PRIMARY KEY (`id`),
	UNIQUE KEY `url` (`url`),
	KEY `domain` (`domain`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8
END;
		$this->database->query($sql);
	} # end method ___install()


	/**
	 * This method handles uninstalling the module
	 * @access public
	 */
	public function ___unInstall()
	{
		$page = $this->pages->get('template=webmention-endpoint');
		$page->delete();

		$template = $this->templates->get('webmention-endpoint');

		if ( !is_null($template) && $template->getNumPages() == 0 )
		{
			$fg = $template->fieldgroup;

			wire('templates')->delete($template);

			wire('fieldgroups')->delete($fg);
		}

		$this->database->query("DROP TABLE IF EXISTS {$this->className}_send_queue");
		$this->database->query("DROP TABLE IF EXISTS {$this->className}_referer_queue");
		$this->database->query("DROP TABLE IF EXISTS {$this->className}_vouches");
	} # end method ___unInstall()


	/**
	 * Initialize the module
	 *
	 * ProcessWire calls this when the module is loaded. For 'autoload' modules, this will be called
	 * when ProcessWire's API is ready. As a result, this is a good place to attach hooks.
	 * @access public
	 */
	public function init()
	{
		$date = new DateTime();
		$this->gmt_offset = $date->format('P');

		# if: not using the latest schema; upgrade database
		if ( $this->schema_version < self::SCHEMA_VERSION )
		{
			$this->updateDatabaseSchema();
		}

		$this->addHook('LazyCron::every30Seconds', $this, 'processReferer');
		$this->addHook('LazyCron::every30Seconds', $this, 'sendWebmentions');
		$this->addHook('LazyCron::everyDay', $this, 'processVouchWhitelist');

		# if: auto-process received webmentions
		if ( $this->frequency_to_process )
		{

			switch ( $this->frequency_to_process )
			{
				case 1:
					$cron_frequency = 'everyMinute';
				break;

				case 60:
					$cron_frequency = 'everyHour';
				break;

				default:
					$cron_frequency = sprintf('every%dMinutes', $this->frequency_to_process);
				break;
			}

			$this->addHook('LazyCron::' . $cron_frequency, $this, 'processWebmentions');
		} # end if: auto-process received webmentions


		/**
		 * Add the Webmention endpoint Link: header, if the page supports webmentions
		 */
		$this->addHookBefore('PageRender::renderPage', function($event) {

			$this->recordReferer();

			$page = $event->page;
			$this->findFieldtypeWebmentions($page);

			# if: page supports webmentions, send Link: header
			if ( $this->webmention_field )
			{
				$endpoint = ( $this->custom_endpoint ) ? $this->custom_endpoint : $this->pages->get('template=webmention-endpoint')->httpUrl;
				$link = sprintf('Link: <%s>; rel="webmention"', $endpoint);
				header($link, FALSE);
			} # end if

		});


		/**
		 * Receive webmentions when POSTed to the webmention-endpoint template
		 */
		$this->addHookBefore('ProcessPageView::ready', function($event) {

			$page = $event->page;

			if ( $page->template == 'webmention-endpoint' && count($this->input->post) )
			{
				$this->receiveWebmention();
			}

		});


		/**
		 * Add 'Send Webmentions' checkbox to page edit form
		 */
		$this->addHook('ProcessPageEdit::buildForm', function($event) {

			$page = $event->object->getPage();
			$this->findFieldtypeWebmentions($page);

			if ( $this->webmention_field )
			{
				# set up the checkbox field
				$field = $this->modules->get('InputfieldCheckbox');
				$field->attr('id+name', 'send_webmentions');
				$field->attr('value', 1);
				$field->attr('class', $field->class);
				$field->label = 'Send Webmentions';

				# if: check the box by default on the first page edit
				if ( $page->created === $page->modified )
				{
					$field->attr('checked', 'checked');
				} # end if

				$event->return = $event->return->append($field);
			}

		});


		/**
		 * Perform webmention actions after page save
		 */
		$this->addHook('Pages::saved', function($event) {

			$page = $event->arguments('page');

			# if: page is published, and user checked 'send webmention'
			if ( !$page->is(Page::statusUnpublished) && $this->input->post->send_webmentions == 1 )
			{
				$fields_to_parse = explode(',', $this->fields_to_parse);

				$urls = array();

				# loop: each field to parse for webmention-able URLs
				foreach ( $fields_to_parse as $field )
				{

					# if: page has the field; extract URLs
					if ( $page->template->hasField($field) )
					{
						$urls = array_merge($urls, $this->extractURLs($page->{$field}, $page->httpUrl));
					} # end if

				} # end loop

				$urls = array_merge($urls, $this->getWebmentionURLs($page->id));
				$urls = array_unique($urls);

				$params = array();

				if ( $page->is_private )
				{
					$params = array('private' => 1);
				}

				if ( $urls )
				{
					$this->queueWebmentions($urls, $page->httpUrl, $page->id, $params);
				}

			} # end if: checked 'send webmention'

		});
	} # end method init()


	/**
	 * This method handles finding if the page has FieldtypeWebmentions
	 * @param Page $page
	 * @access private
	 * @return bool
	 */
	private function findFieldtypeWebmentions(Page $page)
	{

		# loop: each field for this page
		foreach ( $page->template->fields as $field )
		{

			if ( $field->type instanceof FieldtypeWebmentions )
			{
				$this->webmention_field = $field;
				return TRUE;
			}

		} # end loop

		return FALSE;
	} # end method findFieldtypeWebmentions()


	/**
	 * This method initiates processing received webmentions
	 * @access public
	 * @return bool
	 */
	public function processWebmentions()
	{

		foreach ( $this->fields as $field )
		{

			if ( $field->type instanceof FieldtypeWebmentions )
			{
				$fields[] = $field;
			}

		}

		$count = count($fields);

		if ( !$count )
		{
			$this->log->save('webmentions-received', 'No webmention fields found when running processWebmentions');
			return FALSE;
		}

		$field = reset($fields);
		$limit = 5;
		$selector = sprintf('status=%d, limit=%d, type!="legacy", sort=-created', WebmentionItem::statusPending, $limit);

		$webmentions = $field->type->find($field, $selector);

		if ( $webmentions->count() == 0 )
		{
			return TRUE;
		}

		foreach ( $webmentions as $webmention )
		{
			$action = $this->processWebmention($webmention);

			# if: delete the webmention
			if ( $action == WebmentionItem::actionDelete )
			{

				if ( $field->type->deleteWebmention($webmention->getPage(), $field, $webmention) )
				{
					$this->log->save('webmentions-received', sprintf('Deleted webmention %d.', $webmention->id));
					$this->message(sprintf($this->_('Deleted webmention #%d'), $webmention->id));
				}

				continue;
			}

			$this->saveWebmention($webmention);
		}

		return TRUE;
	} # end method processWebmentions()


	/**
	 * Verify the source links to the target
	 * @param string $html source HTML, already retrieved during webmention processing
	 * @param string $source source URL, used to resolve relative links
	 * @param string $target target URL
	 * @access public
	 * @return bool
	 */
	public function verifyLinksTo($html, $source, $target)
	{
		$target_relative = $this->buildRelativeURL($target);
		$target_hostname = strtolower(parse_url($target, PHP_URL_HOST));
		$target_scheme_hostname = strtolower(
			sprintf('%s://%s',
				parse_url($target, PHP_URL_SCHEME),
				parse_url($target, PHP_URL_HOST)
			)
		);

		libxml_use_internal_errors(true);
		$dom = new DOMDocument('1.0', 'UTF-8');
		$dom->loadHTML($html);
		$dom->preserveWhiteSpace = false;

		# get all <a> DOMElements
		$a_elements = $dom->getElementsByTagName('a');

		# loop: each <a> DOMElement
		foreach ( $a_elements as $a )
		{

			# if: <a> element has href attribute
			if ( $a->hasAttribute('href') )
			{
				$url = Mf2\resolveUrl($source, $a->getAttribute('href'));

				# if: verify linkback without scheme
				if ( $this->http_https_same )
				{
					$hostname = strtolower(parse_url($url, PHP_URL_HOST));

					# if: link hostnames match (not case-sensitive) and relative URLs match
					if ( $hostname === $target_hostname && $target_relative === $this->buildRelativeURL($url) )
					{
						return true;
					} # end if

				}
				# else: verify linkback exactly
				else
				{
					$scheme_hostname = strtolower(
						sprintf('%s://%s',
							parse_url($url, PHP_URL_SCHEME),
							parse_url($url, PHP_URL_HOST)
						)
					);

					# if: link scheme+hostnames match (not case-sensitive) and relative URLs match
					if ( $scheme_hostname == $target_scheme_hostname && $target_relative = $this->buildRelativeURL($url) )
					{
						return true;
					} # end if

				} # end if

			} # end if

		} # end loop

		return false;
	} # end method verifyLinksTo()


	/**
	 * This method processes a webmention
	 * @param WebmentionItem $webmention
	 * @access public
	 * @return bool
	 */
	public function processWebmention(WebmentionItem &$webmention)
	{
		$http = new WireHttp();

		## Verify the target URL
		$target_response = $http->get($webmention->target_url);
		$http_code = $http->getHttpCode();

		# if: webmention target is HTTP 404
		if ( $http_code == 404 )
		{
			$webmention->content = $webmention->name = sprintf('The target URL %s was not found.', $webmention->target_url);
			$webmention->status = WebmentionItem::statusError;
			$webmention->visibility = WebmentionItem::visibilityPrivate;
			$this->log->save('webmentions-received', $webmention->name);

			return WebmentionItem::actionProcess;
		} # end if

		$http_headers = $http->getResponseHeaders();

		# if: redirected; update final URL
		if ( !empty($http_headers['location']) )
		{
			$webmention->target_url = $http_headers['location'];
		}

		## Verify the source URL
		$response = $http->get($webmention->source_url);
		$http_code = $http->getHttpCode();

		# if: webmention source is HTTP 404
		if ( $http_code == 404 )
		{
			$webmention->content = $webmention->name = sprintf('The source URL %s was not found.', $webmention->source_url);
			$webmention->status = WebmentionItem::statusError;
			$webmention->visibility = WebmentionItem::visibilityPrivate;
			$this->log->save('webmentions-received', $webmention->name);

			return WebmentionItem::actionProcess;
		}
		# if: webmention source is HTTP 410
		else if ( $http_code == 410 )
		{

			if ( $this->verbose_logging )
			{
				$this->log->save('webmentions-received', sprintf('Source URL %s is HTTP 410. Webmention %d will be deleted.', $webmention->source_url, $webmention->id));
			}

			return WebmentionItem::actionDelete;
		} # end if

		$http_headers = $http->getResponseHeaders();

		# if: redirected; update final URL
		if ( !empty($http_headers['location']) )
		{
			$webmention->source_url = $http_headers['location'];
		}

		/**
		 * If the soruce URL is already listed in the target page,
		 * that means this is likely a notification rather than
		 * a mention or reply. Do nothing for now until more experimentation
		 * is done with update/delete and reply-contexts.
		 * Discussion: https://indieweb.org/reply-context#CRUD
		 */

		$source_base_url = parse_url($webmention->source_url, PHP_URL_SCHEME) . '://' . parse_url($webmention->source_url, PHP_URL_HOST);
		$source_pattern = '#(?i)' . $source_base_url . '(?-i)' . preg_replace('#' . $source_base_url . '#i', '', $webmention->source_url) . '#';

		# if: source URL is already linked from the target; set a simple private 'linked' message
		if ( preg_match($source_pattern, $target_response) === 1 )
		{
			$webmention->content = $webmention->name = sprintf('The URL %s sent a notification to %s', $webmention->source_url, $webmention->target_url);
			$webmention->status = WebmentionItem::statusApproved;
			$webmention->visibility = WebmentionItem::visibilityPrivate;

			return WebmentionItem::actionProcess;
		} # end if

		# if: target URL linked from source
		if ( $this->verifyLinksTo($response, $webmention->source_url, $webmention->target_url) )
		{
			$webmention->status = WebmentionItem::statusApproved;

			# parse HTML for microformats2
			$parsed_content = $this->fetchMicroformats($response, $webmention->source_url);
			$webmention->set('microformats', json_encode($parsed_content, JSON_PRETTY_PRINT));

			# parse first h-entry
			$entry = $this->parseFirstEntry($parsed_content, $webmention);
			$author = NULL;

			# if: h-entry found; parse author from h-card
			if ( $entry )
			{
				$author = $this->getAuthorship($entry, $parsed_content, $webmention);
			}
			# else: no h-entry; generic 'mentioned this' content
			else
			{
				$webmention->content = $webmention->name = sprintf('mentioned this');
			} # end if

			# if: authorship algorithm did not find an author; use domain name as default author
			if ( !$author )
			{
				$author = $this->parseDefaultAuthor($webmention->source_url, $webmention);
			}

			unset($parsed_content);
			unset($entry);
			unset($author);
		}
		# else:
		else
		{
			$webmention->content = $webmention->name = sprintf('The URL %s was not found in %s', $webmention->target_url, $webmention->source_url);
			$webmention->status = WebmentionItem::statusError;
			$webmention->visibility = WebmentionItem::visibilityPrivate;

			return WebmentionItem::actionProcess;
		} # end if

		return WebmentionItem::actionProcess;
	} # end method processWebmention()


	/**
	 * This method saves a webmention field
	 * @param WebmentionItem $webmention
	 * @access public
	 * @return bool
	 */
	public function saveWebmention(WebmentionItem $webmention)
	{
		$page = $webmention->getPage();
		$field = $webmention->getField();

		$page->{$field->name}->setTrackChanges(TRUE);
		$page->{$field->name}->set($webmention->id, $webmention);
		$page->setOutputFormatting(FALSE);

		if ( !$page->save($field->name, array('quiet' => TRUE)) )
		{
			$this->log->save('webmentions-received', sprintf('There was an error saving webmention ID %d', $webmention->id));
			return FALSE;
		}

		# clear the page cache
		$PageRender = $this->wire('modules')->get('PageRender');
		$cf = $PageRender->getCacheFile($page);

		if ( $cf->exists() )
		{
			$cf->remove();
		}

		return TRUE;
	} # end method saveWebmention()


	/**
	 * This method handles incoming webmentions.
	 * Basic validations are performed, but the source URL is not parsed/verified.
	 * @access private
	 */
	private function receiveWebmention()
	{
		# TODO: Take into account the q= quality factor of Accept: headers.
		$http_accept = $_SERVER['HTTP_ACCEPT'];

		if ( $http_accept_override = $this->input->post('HTTP_ACCEPT') )
		{
			$http_accept = $http_accept_override;
		}

		if ( strpos($http_accept, 'application/json') !== FALSE )
		{
			$content_type = 'application/json';
		}
		else if ( strpos($http_accept, 'text/plain') !== FALSE )
		{
			$content_type = 'text/plain';
		}
		else
		{
			$content_type = 'text/html';
		}

		$is_www_form_urlencoded = strpos($_SERVER['CONTENT_TYPE'], 'application/x-www-form-urlencoded');

		# if: request is the correct content-type
		if ( $is_www_form_urlencoded !== FALSE )
		{
			$source = $this->input->post('source');
			$target = $this->input->post('target');
			$vouch = $this->input->post('vouch');
			$source_sanitized = filter_var($source, FILTER_VALIDATE_URL);
			$target_sanitized = filter_var($target, FILTER_VALIDATE_URL);
			$vouch_sanitized = filter_var($vouch, FILTER_VALIDATE_URL);

			# if: source is missing
			if ( empty($source) )
			{
				$message = 'Webmention “source” parameter is missing.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			} # end if

			# if: source is not a valid URL
			if ( empty($source_sanitized) )
			{
				$message = 'Webmention “source” parameter is not a valid URL.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			}

			# if: target is missing
			if ( empty($target) )
			{
				$message = 'Webmention “target” parameter is missing.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			} # end if

			# if: target is not a valid URL
			if ( empty($target_sanitized) )
			{
				$message = 'Webmention “target” parameter is not a valid URL.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			} # end if

			# if: source equals target
			if ( $source_sanitized == $target_sanitized )
			{
				$message = 'Webmention “source” and “target” parameters cannot be the same URL.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			}

			# if: vouch is required and missing
			if ( $this->is_vouch_required && empty($vouch) )
			{
				$message = 'Webmention “vouch” parameter is required.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(449, $content_type, $message);
			} # end if

			# if: vouch supplied, but is not a valid url
			if ( $vouch && empty($vouch_sanitized) )
			{
				$message = 'Webmention “vouch” parameter is is not a valid URL.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(449, $content_type, $message);
			} # end if

			if ( strtolower(parse_url($target, PHP_URL_HOST)) !== strtolower($this->config->httpHost) )
			{
				$message = 'Webmention “target” hostname is not valid.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			}

			$path = preg_replace('#' . $this->config->urls->root . '#', '/', parse_url($target, PHP_URL_PATH));
			$page = $this->pages->get($path);

			if ( $page instanceof NullPage )
			{
				$message = 'Webmention “target” is not a valid URL at this domain.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			}

			$target = $page->httpUrl;

			$this->findFieldtypeWebmentions($page);

			# if: no FieldtypeWebmention field on the target page; does not accept webmentions
			if ( empty($this->webmention_field) )
			{
				$message = 'Webmention “target” does not accept webmentions.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			}

			# if: vouch not accepted
			if ( $this->is_vouch_required && !$this->verifyReceivedVouch($vouch, $source) )
			{
				$message = 'Webmention “vouch” was not accepted.';
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
				$this->httpResponse(400, $content_type, $message);
			}

			$http = new WireHttp();
			$WebmentionField = $this->webmention_field->name;

			# Check source URL for redirects
			$response = $http->status($source);

			if ( $response )
			{
				$http_headers = $http->getResponseHeaders();

				# if: redirected; update final URL
				if ( !empty($http_headers['location']) )
				{
					$location = array_pop($http_headers['location']);
					$source = Mf2\resolveUrl($source, $location);
				}

			}

			# Check target URL for redirects
			$response = $http->status($target);

			if ( $response )
			{
				$http_headers = $http->getResponseHeaders();

				# if: redirected; update final URL
				if ( !empty($http_headers['location']) )
				{
					$location = array_pop($http_headers['location']);
					$target = Mf2\resolveUrl($target, $location);
				}

			}

			$md5key = md5($source . $target);
			$item = $page->{$WebmentionField}->get('md5key=' . $md5key);

			# if: update existing webmention
			if ( $item )
			{

				if ( $item->status != WebmentionItem::statusPending )
				{
					$page->$WebmentionField->setTrackChanges(TRUE);

					$new_item = $item;
					$this->processWebmention($new_item);

					$page->$WebmentionField->replace($item, $new_item);
				}

			}
			# else: add new webmention
			else
			{
				$webmention = new WebmentionItem();

				$webmention->set('md5key', $md5key);
				$webmention->set('source_url', $source);
				$webmention->set('target_url', $target);
				$webmention->set('vouch_url', $vouch);
				$webmention->set('status', WebmentionItem::statusPending);
				$webmention->set('visibility', WebmentionItem::visibilityPublic);
				$webmention->set('created', date('Y-m-d H:i:s'));

				$page->$WebmentionField->add($webmention);
			} # end if

			$outputFormatting = $page->outputFormatting;
			$page->setOutputFormatting(FALSE);

			$page->save($WebmentionField, array('quiet' => TRUE));
			$page->setOutputFormatting($outputFormatting);

			$message = sprintf('Webmention from %s queued for processing.', parse_url($source, PHP_URL_HOST));

			if ( $this->verbose_logging )
			{
				$this->log->save('webmentions-received', sprintf('%s|%s|%s', $message, $_SERVER['REMOTE_ADDR'], http_build_query($this->input->post->getArray())) );
			}

			$this->httpResponse(202, $content_type, $message);
		}
		# else: incorrect content-type
		else
		{
			$message = 'Webmention must be posted with Content-Type: application/x-www-form-urlencoded.';
			$this->log->save('webmentions-received',
				sprintf('%s|%s|%s',
					$message,
					$_SERVER['REMOTE_ADDR'],
					''
				)
			);
			$this->httpResponse(400, $content_type, $message);
		} # end if

		$message = 'An unexpected error occurred.';
		$this->log->save('webmentions-received',
			sprintf('%s|%s|%s',
				$message,
				$_SERVER['REMOTE_ADDR'],
				http_build_query($this->input->post->getArray())
			)
		);
		$this->httpResponse(500, $content_type, $message);
	} # end method receiveWebmention()


	/**
	 * This method returns an array of URLs webmentions were sent to for a page ID
	 * @param int $page_id
	 * @access public
	 * @return array
	 */
	public function getWebmentionURLs($page_id)
	{
		$statement = $this->database->prepare("SELECT target FROM {$this->className}_send_queue WHERE pages_id = ? ORDER BY created ASC");
		$result = $statement->execute(array($page_id));

		if ( $result === FALSE || $statement->rowCount() == 0 )
		{
			return array();
		}

		$urls = array();

		# loop: each webmention to send
		while ( $row = $statement->fetch(PDO::FETCH_ASSOC) )
		{
			$urls[] = $row['target'];
		} # end loop

		return $urls;
	} # end method getWebmentionURLs()


	/**
	 * This method adds URLs to a queue for asynchronous webmention sending
	 * @param array $urls
	 * @param string $source_url
	 * @param int $page_id
	 * @param array $params
	 * @access public
	 * @return bool
	 */
	public function queueWebmentions($urls, $source_url, $page_id, $params = array())
	{
		$unique_urls = array_unique($urls);
		$source = $this->sanitizer->url($source_url);
		$json_params = '';

		if ( $params )
		{
			$json_params = json_encode($params);
		}

		$statement = $this->database->prepare("INSERT INTO {$this->className}_send_queue SET pages_id = ?, source = ?, target = ?, params = ?, created = NOW(), modified = NOW()");

		# loop: each unique URL
		foreach ( $unique_urls as $url )
		{
			$target = $this->sanitizer->url($url);

			# if: only queue webmention is source and target exist
			if ( $source && $target )
			{
				$result = $statement->execute(array($page_id, $source, $target, $json_params));
			} # end if

		} # end loop

		return TRUE;
	} # end method queueWebmentions()


	/**
	 * This method initiates sending queued webmentions
	 * @access public
	 */
	public function sendWebmentions()
	{
		# fetch webmentions to be sent
		$result = $this->database->query("SELECT * FROM {$this->className}_send_queue WHERE processed IS NULL ORDER BY created ASC LIMIT 5");

		if ( $result === FALSE || $result->rowCount() == 0 )
		{
			return;
		}

		$statement_processed = $this->database->prepare("UPDATE {$this->className}_send_queue SET processed = NOW() WHERE id = ?");

		# array of webmention responses
		$responses = array();

		// $Micropub = $this->modules->get('Micropub');
		// $this->log->save('webmentions-sent', 'sendWebmention Micropub module called.');

		# loop: each webmention to send
		while ( $row = $result->fetch(PDO::FETCH_ASSOC) )
		{
			$extra_parameters =
			$params = array();

			if ( $row['params'] )
			{
				$params = json_decode($row['params'], TRUE);
			}

			/*
			TODO: Make this work with Micropub optional
			if ( isset($params['private']) )
			{
				$extra_parameters['code'] = $Micropub->getCode($row['source'], array('target' => $row['target']));
			}
			*/

			$responses[] = $this->sendWebmention($row['source'], $row['target'], $extra_parameters);

			$result_processed = $statement_processed->execute(array($row['id']));
		} # end loop

		return $responses;
	} # end method sendWebmentions()


	/**
	 * This method sends an individual webmention
	 * @param string $source
	 * @param string $target
	 * @param array $extra_parameters
	 * @access public
	 */
	public function sendWebmention($source, $target, $extra_parameters = array())
	{
		$http = new WireHttp();

		$endpoint_data = null;

		# if: URL starts with http:// or https://
		if ( strpos($target, 'http://') === 0 || strpos($target, 'https://') === 0 )
		{
			$endpoint_data = $this->discovery($target);
		} # end if

		# if: no endpoint found
		if ( !$endpoint_data )
		{

			if ( $this->verbose_logging )
			{
				$this->log->save('webmentions-sent', sprintf('No endpoint found for %s.', $target));
			}

			return null;
		}

		# if: vouch available for this target
		if ( $vouch = $this->findVouchFor($target) )
		{
			$extra_parameters['vouch'] = $vouch;
		}

		$endpoint = $endpoint_data['endpoint'];

		# if: endpoint is a loopback
		if ( $this->isLoopback($endpoint) )
		{
			$this->log->save('webmentions-sent', sprintf('Endpoint %s is localhost or a loopback address. Skipping.', $endpoint));
			return FALSE;
		} # end if

		# if: sending pingback as fallback
		if ( $endpoint_data['type'] == 'pingback' )
		{
			$data = xmlrpc_encode_request('pingback.ping', array($source, $target), array('verbosity' => 'no_white_space', 'encoding' => 'utf-8'));

			$http->setHeader('Content-Type', 'application/xml');
		}
		# else: sending webmention
		else
		{
			$data = array_merge(
				compact('source', 'target'),
				$extra_parameters
			);

			$http->setHeader('Accept', 'application/json, application/xml, text/html');
		}

		if ( $this->verbose_logging )
		{
			$this->log->save('webmentions-sent', sprintf('Initiate sending %s from %s to %s.', $endpoint_data['type'], $source, $target));
		}

		$response = $http->post($endpoint, $data);
		$http_code = $http->getHttpCode();

		/*
		if ( !$response )
		{
			$this->log->save('webmentions-sent', sprintf('Error sending webmention - %s: %s', $http_code, $http->getError()));
			return;
		}
		*/

		# if: successful webmention
		if ( in_array($http_code, array('200', '201', '202')) )
		{
			$message = sprintf('Sent webmention for %s successfully to %s.', $target, $endpoint);
		}
		# else: error
		else
		{
			$message = sprintf('Error sending webmention for %s to %s.', $target, $endpoint);
		} # end if

		$this->log->save('webmentions-sent', sprintf('%s|%s|%s|%s', $message, $http_code, http_build_query($data), $response));

		return $response;
	} # end method sendWebmention()


	/**
	 * This method handles extracting URLs from the supplied text
	 * @param string $text
	 * @param string $url
	 * @access protected
	 * @return array
	 */
	protected function extractURLs($text, $url)
	{
		$response = array();

		# regex pattern to match URLs
		$pattern_absolute = "~\b(?:https?://)[\w-]*[a-z][\w-]*(?:\.[\w-]+)+(?:/[\w\./%+?=&(amp;)?#\~-]+)?\b~i";
		$pattern_relative = '#(?<=href=(?:"|\')|href=)(?!http|mailto)[^"\']+(?=(?:"|\'|>))#U';

		# match all URLs in the text
		preg_match_all($pattern_absolute, $text, $matches_absolute, PREG_SET_ORDER);
		preg_match_all($pattern_relative, $text, $matches_relative, PREG_SET_ORDER);

		# make all relative URLs absolute
		array_walk_recursive($matches_relative, array($this, 'resolveUrl'), $url);

		$matches = array_merge($matches_absolute, $matches_relative);

		foreach ( $matches as $match )
		{
			$response[] = reset($match);
		}

		$response = array_unique($response);

		return $response;
	} # end method extractURLs()


	/**
	 * This method builds a relative URL
	 * @param string $url
	 * @access protected
	 * @return string
	 */
	protected function buildRelativeURL($url)
	{
		$relative = '';
		$relative .= parse_url($url, PHP_URL_PATH);
		$relative .= ( $query = parse_url($url, PHP_URL_QUERY) ) ? '?' . $query : '';
		$relative .= ( $fragment = parse_url($url, PHP_URL_FRAGMENT) ) ? '#' . $fragment : '';

		return $relative;
	} # end method buildRelativeURL()


	/**
	 * This method is a shortcut to Mf2\resolveUrl()
	 * @param array
	 * @access protected
	 * @return string
	 */
	protected function resolveUrl(&$path, $key, $url_base)
	{
		$path = Mf2\resolveUrl($url_base, $path);

		return $path;
	} # end method resolveUrl()


	/**
	 * This method resolves a URL's 3xx redirects and returns the final URL
	 * @param string $url
	 * @return string
	 */
	protected function resolveRedirects($url)
	{
		$http = new WireHttp();

		$response = $http->get($url);
		$http_headers = $http->getResponseHeaders();

		# if: redirected; update final URL
		if ( !empty($http_headers['location']) )
		{
			$url = $http_headers['location'];
		}

		return $url;
	} # end method resolveRedirects()


	/**
	 * This method handles discovery of webmention endpoint
	 * @param string $url
	 * @access protected
	 * @return string
	 */
	protected function discovery($url)
	{
		$headers = $this->fetchHead($url);

		## 1. Look for Link: header with webmention rel-value

		# if: link headers
		if ( !empty($headers['link']) )
		{

			if ( !is_array($headers['link']) )
			{

				if ( strpos($headers['link'], ',') )
				{
					$temp_links = explode(',', $headers['link']);
					$headers['link'] = array_map('trim', $temp_links);
				}
				else
				{
					$headers['link'] = array($headers['link']);
				}

			}

			# loop: each header link
			foreach ( $headers['link'] as $header )
			{
				# match rel=webmention link header
				preg_match('#\<(.*?)\>\s*\;\s*rel\=\"?(?:.*?)webmention(?:.*?)\"?#', $header, $matches);

				# if: rel=webmention link header found
				if ( count($matches) == 2 )
				{
					$endpoint = \Mf2\resolveUrl($url, array_pop($matches));

					return array(
						'type'		=> 'webmention',
						'endpoint'	=> $this->resolveRedirects($endpoint)
					);
				} # end if

			} # end loop

		} # end if: link headers

		## 2. Look for <link> elements with webmention rel-value

		$links = $this->fetchLinkElements($url);

		# if: webmention <link> element found
		if ( !empty($links['webmention']) )
		{
			$endpoint = \Mf2\resolveUrl($url, reset($links['webmention']));

			return array(
				'type'		=> 'webmention',
				'endpoint'	=> $this->resolveRedirects($endpoint)
			);
		} # end if

		## 3. Look for X-Pingback: header

		# if: X-Pingback: header found
		if ( !empty($headers['pingback']) )
		{
			return array(
				'type'		=> 'pingback',
				'endpoint'	=> reset($headers['pingback'])
			);
		} # end if: link headers

		## 4. Look for <link> elements with pingback rel-value

		# if: pingback <link> element found
		if ( !empty($links['pingback']) )
		{
			return array(
				'type'		=> 'pingback',
				'endpoint'	=> reset($links['pingback'])
			);
		} # end if

		return NULL;
	} # end method discovery()


	/**
	 * This method determines if a URL is is a loopback
	 * @param string $url
	 * @access public
	 * @return bool
	 */
	public function isLoopback($url)
	{
		$domain = parse_url($url, PHP_URL_HOST);

		if ( $domain == 'localhost' )
		{
			return TRUE;
		}

		$records = dns_get_record($domain);
		$ips = array();

		# loop: each DNS record
		foreach ( $records as $record )
		{

			# if: host matches and the record is A or AAAA
			if ( $record['host'] == $domain && in_array($record['type'], array('A', 'AAAA')) )
			{
				$ip = ( $record['type'] == 'A' ) ? $record['ip'] : $record['ipv6'];

				# if: the IP address is in the reserved range, this is a loopback
				if ( filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_RES_RANGE) === FALSE )
				{
					return TRUE;
				} # end if

			} # end if

		} # end loop

		return FALSE;
	} # end method isLoopback()


	/**
	 * This method fetches the body of a URL
	 * @param string $url
	 * @access protected
	 */
	protected function fetchBody($url)
	{
		$http = new WireHttp();

		$response = $http->get($url);

		if ( !$response )
		{
			return '';
		}

		return $response;
	} # end method fetchBody()


	/**
	 * This method performs a HEAD request and returns an array of headers
	 * @param string $url
	 * @access protected
	 */
	protected function fetchHead($url)
	{
		$http = new ProcessWireShim\WireHttp();

		$return_headers = array(
			'link'		=> array(),
			'pingback'	=> array()
		);

		$response = $http->status($url);

		if ( !$response )
		{
			return $return_headers;
		}

		$http_headers = $http->getResponseHeaders();

		return array_intersect_key($http_headers, $return_headers);
	} # end method fetchHead()


	/**
	 * This method parses the <link> elements from HTML
	 * @param string $url
	 * @access protected
	 * @return array
	 */
	protected function fetchLinkElements($url)
	{
		$links = array();

		$body = $this->fetchBody($url);

		if ( !$body )
		{
			return $links;
		}

		libxml_use_internal_errors(TRUE);
		$dom = new DOMDocument('1.0', 'UTF-8');
		$dom->loadHTML($body);
		$dom->preserveWhiteSpace = FALSE;

		$element_types = array('a', 'link');

		# loop: each type of element
		foreach ( $element_types as $element )
		{
			# get the DOMNodeList of links
			$link_elements = $dom->getElementsByTagName($element);

			# loop: each DOMElement
			foreach ( $link_elements as $link )
			{
				$rel = $link->getAttribute('rel');
				$href = $link->getAttribute('href');
				$rels = explode(' ', $rel);

				foreach ( $rels as $temp_rel )
				{
					$rel = trim($temp_rel);

					if ( empty($links[$rel]) )
					{
						$links[$rel] = array($href);
					}
					else
					{
						$links[$rel][] = $href;
					}

				}

			} # end loop

		} # end loop

		return $links;
	} # end method fetchLinkElements()


	/**
	 * This method handles sending an HTTP response
	 * @param int $http_response_code
	 * @param string $content_type
	 * @param string $message
	 * @access private
	 */
	private function httpResponse($http_response_code, $content_type, $message)
	{

		switch ( $content_type )
		{
			case 'application/json':
				$body = json_encode(array('message' => $message));
			break;

			case 'text/plain':
				$body = $message;
			break;

			default:
			case 'text/html':
				$body = <<< END
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8"/>
	<title>Webmention Response: {$http_response_code}</title>
</head>

<body>
	<p> {$message} </p>
</body>

</html>
END;
			break;
		}

		$content_header = sprintf('Content-Type: %s; charset=utf8', $content_type);

		header($content_header);

		if ( function_exists('http_response_code') )
		{
			http_response_code($http_response_code);
		}
		else if ( $text = $this->http_response_codes[$http_response_code] )
		{
			$protocol = ( isset($_SERVER['SERVER_PROTOCOL']) ) ? $_SERVER['SERVER_PROTOCOL'] : 'HTTP/1.0';
			header($protocol . ' ' . $http_response_code . ' ' . $text);
		}

		echo $body;
		exit;
	} # end method httpResponse()


	/**
	 * This method retrieves microformat content from HTML
	 * Returns FALSE if no microformats found in the HTML
	 * @param string $html
	 * @param string $url
	 * @access public
	 * @return mixed
	 */
	public function fetchMicroformats($html, $url)
	{
		# parse the content for microformats
		$parsed = Mf2\parse($html, $url);

		# if: parsed content is microformat collection
		if ( Mf2helper\isMicroformatCollection($parsed) )
		{
			return $parsed;
		}
		# else:
		else
		{
			return FALSE;
		} # end if

	} # end method fetchMicroformats()


	/**
	 * This method handles parsing the first h-entry in a microformat collection
	 * Returns FALSE if no h-entry found in the collection
	 * @param array $collection
	 * @param WebmentionItem $webmention
	 * @access public
	 * @return mixed
	 */
	public function parseFirstEntry($collection, WebmentionItem &$webmention)
	{
		# find h-entry in collection
		$entries = Mf2helper\findMicroformatsByType($collection, 'h-entry');

		# if: one or more h-entry found
		if ( $entries )
		{
			$entry = reset($entries);

			$in_reply_to = array();
			$target_url = $webmention->target_url;

			# if: in-reply-to found
			if ( !empty($entry['properties']['in-reply-to']) && is_array($entry['properties']['in-reply-to']) )
			{

				foreach ( $entry['properties']['in-reply-to'] as $item )
				{

					if ( is_array($item) )
					{
						$in_reply_to[] = Mf2helper\getPlaintext($item, 'url');
					}
					else if ( is_string($item) )
					{
						$in_reply_to[] = $item;
					}

				} # end loop

			} # end if

			# set type to 'reply' if in-reply-to matches the target; otherwise 'mention'
			$type = ( in_array($target_url, $in_reply_to) ) ? 'reply' : 'mention';
			$webmention->set('type', $type);

			$like_of = Mf2helper\getPlaintextArray($entry, 'like-of');
			$repost_of = Mf2helper\getPlaintextArray($entry, 'repost-of');
			$rsvp = Mf2helper\getPlaintext($entry, 'rsvp');

			# if: if like-of matches target, set the flag
			if ( $like_of && in_array($target_url, $like_of) )
			{
				$webmention->set('is_like', 1);
			}

			# if: if repost-of matches target, set the flag
			if ( $repost_of && in_array($target_url, $repost_of) )
			{
				$webmention->set('is_repost', 1);
			}

			# if: rsvp
			if ( $rsvp )
			{
				$webmention->set('is_rsvp', 1);
			}

			$webmention->set('name', Mf2helper\getPlaintext($entry, 'name'));
			$webmention->set('content', Mf2helper\getHtml($entry, 'content'));
			$webmention->set('content_plain', Mf2helper\getPlaintext($entry, 'content'));

			if ( $url = Mf2helper\getPlaintext($entry, 'url') )
			{
				$webmention->set('url', $url);
			}

			$published = Mf2helper\getDateTimeProperty('published', $entry, TRUE);
			$array_date = $this->parseDateTime($published, $webmention->created);
			$webmention->set('published', $array_date['date']);
			$webmention->set('published_offset', $array_date['has_timezone']);

			$updated = Mf2helper\getDateTimeProperty('updated', $entry, TRUE);
			$array_date = $this->parseDateTime($updated, $webmention->created);
			$webmention->set('updated', $array_date['date']);
			$webmention->set('updated_offset', $array_date['has_timezone']);

			return $entry;
		}
		# else: no h-entry found
		else
		{
			$webmention->set('url', $webmention->source_url);
			$webmention->published = $webmention->updated = NULL;
			return FALSE;
		} # end if

	} # end method parseFirstEntry()


	/**
	 * This method handles parsing the first h-card in a microformat collection
	 * Returns FALSE if no h-card found in the collection
	 * @param array $collection
	 * @param WebmentionItem $webmention
	 * @access private
	 * @return mixed
	 */
	private function parseFirstCard($collection, WebmentionItem &$webmention)
	{
		# find h-card in collection
		$cards = Mf2helper\findMicroformatsByType($collection, 'h-card');

		# if: one or more h-card found
		if ( $cards )
		{
			$card = reset($cards);

			$webmention->set('author_name', Mf2helper\getPlaintext($card, 'name'));
			$webmention->set('author_photo', Mf2helper\getPlaintext($card, 'photo'));
			$webmention->set('author_logo', Mf2helper\getPlaintext($card, 'logo'));
			$webmention->set('author_url', reset(Mf2helper\getPlaintextArray($card, 'url')));

			return TRUE;
		}
		# else: no h-card found
		else
		{
			return FALSE;
		} # end if

	} # end method parseFirstCard()


	/**
	 * This method performs the authorship algorithm
	 * @param array $entry
	 * @param array $mf2
	 * @param WebmentionItem $webmention
	 * @access public
	 * @return bool
	 */
	public function getAuthorship($entry, $mf2, WebmentionItem &$webmention)
	{
		$author = '';
		$author_page = '';

		# if: author property
		if ( Mf2helper\hasProp($entry, 'author') )
		{
			$author = Mf2helper\getAuthor($entry);
		}
		# else: check h-feed for author property
		else
		{
			# TODO: authorship step 4. Not sure it's pertinent to this plugin, though.
		} # end if

		# if: author property
		if ( $author )
		{

			# if: author h-card found
			if ( Mf2helper\isMicroformat($author) )
			{
				return $this->setAuthor($author, $webmention);
			}
			# else if: author value is a URL
			else if ( filter_var($author, FILTER_VALIDATE_URL) )
			{
				$author_page = $author;
			}
			# else: author value is the author's name
			else
			{
				$webmention->set('author_name', $author);
				return TRUE;
			} # end if

		} # end if

		# if: no author_page set yet; rel-author exists
		if ( !$author_page && !empty($mf2['rels']['author']) )
		{
			$author_page = reset($mf2['rels']['author']);
		} # end if

		# if: parse author_page
		if ( $author_page )
		{
			$http = new WireHttp();

			$response = $http->get($author_page);
			$mf2_author_page = $this->fetchMicroformats($response, $author_page);

			# if: no microformats
			if ( $mf2_author_page === FALSE )
			{
				return FALSE;
			} # end if

			$cards = Mf2helper\findMicroformatsByType($mf2_author_page, 'h-card');

			# loop: each h-card (reference authorship step 7.2)
			foreach ( $cards as $card )
			{
				$u_url = Mf2helper\getPlaintext($card, 'url');
				$u_uid = Mf2helper\getPlaintext($card, 'uid');

				# if: author found
				if ( $u_url == $u_uid && $u_uid == $author_page )
				{
					return $this->setAuthor($card, $webmention, $u_url);
				} # end if: author found

			} # end loop

			# if: rel-mes on original page (reference authorship step 7.3)
			if ( !empty($mf2_author_page['rels']['me']) )
			{

				# loop: each h-card
				foreach ( $cards as $card )
				{
					$u_url = Mf2helper\getPlaintext($card, 'url');

					# if: author found
					if ( in_array($u_url, $mf2_author_page['rels']['me']) )
					{
						return $this->setAuthor($card, $webmention, $u_url);
					} # end if

				} # end loop

			} # end if

			## reference authorship step 7.4

			# h-cards on the original h-entry's page
			$cards = Mf2helper\findMicroformatsByType($mf2, 'h-card');

			# loop: each h-card
			foreach ( $cards as $card )
			{
				$u_url = Mf2helper\getPlaintext($card, 'url');

				# if: author found
				if ( $u_url == $author_page )
				{
					return $this->setAuthor($card, $webmention, $u_url);
				} # end if

			} # end loop

		} # end if

		return FALSE;
	} # end method getAuthorship()


	/**
	 * This method sets the Webmention's author information from the supplied h-card
	 * @param array $card: parsed mf2 h-card
	 * @param WebmentionItem $webmention
	 * @param string $author_url
	 * @access protected
	 * @return bool
	 */
	protected function setAuthor($card, WebmentionItem &$webmention, $author_url = '')
	{
		$webmention->set('author_name', Mf2helper\getPlaintext($card, 'name'));
		$webmention->set('author_photo', $this->cacheImage(Mf2helper\getPlaintext($card, 'photo')) );
		$webmention->set('author_logo', $this->cacheImage(Mf2helper\getPlaintext($card, 'logo')) );

		if ( $author_url )
		{
			$webmention->set('author_url', $author_url);
		}
		else
		{
			$author_urls = Mf2helper\getPlaintextArray($card, 'url');
			$webmention->set('author_url', reset($author_urls));
		}

		return TRUE;
	} # end method setAuthor()


	/**
	 * This method is hookable for caching images.
	 * By default it does nothing, returning the supplied URL.
	 * @param string $url
	 * @access public
	 * @return string
	 */
	public function ___cacheImage($url)
	{
		return $url;
	} # end method ___cacheImage()


	/**
	 * DEPRECATED. See method getAuthorship()
	 * This method handles parsing the first rel-author on a page
	 * @param array $context
	 * @param WebmentionItem $webmention
	 * @access private
	 * @return mixed
	 */
	private function parseRelAuthor($context, WebmentionItem &$webmention)
	{

		# if: rel-author in parsed content
		if ( !empty($context['rels']['author']) )
		{
			$url = reset($context['rels']['author']);

			# if: microformat(s) found at rel-author URL
			if ( $parsed_content = $this->fetchMicroformats($url) )
			{
				# parse the first h-card, if any
				return $this->parseFirstCard($parsed_content, $webmention);
			} # end if

		}
		# else: no rel-author
		else
		{
			return FALSE;
		} # end if

	} # end method parseRelAuthor()


	/**
	 * This method handles parsing the default author information using the source URL
	 * @param string $url
	 * @param WebmentionItem $webmention
	 * @access private
	 */
	private function parseDefaultAuthor($url, WebmentionItem &$webmention)
	{
		$url_parts = parse_url($url);

		$webmention->set('author_name', $url_parts['host']);
		$webmention->set('author_url', sprintf('%s://%s', $url_parts['scheme'], $url_parts['host']));

		return TRUE;
	} # end method parseDefaultAuthor()


	/**
	 * This method handles parsing a date string into Y-m-d H:i:s format, UTC timezone
	 * @param string $string_date
	 * @param string $fallback
	 * @access private
	 * @return mixed
	 */
	private function parseDateTime($string_date, $fallback = NULL)
	{
		$timezone = NULL;
		$parsed = date_parse($string_date);
		$has_timezone = ( isset($parsed['zone']) ) ? TRUE : FALSE;

		if ( empty($string_date) && !empty($fallback) )
		{
			$string_date = $fallback;
		}

		try
		{

			# if: datetime string has timezone
			if ( $has_timezone )
			{
				$date = new DateTime($string_date);
				$timezone = $date->getTimezone()->getName();

				# if: date is not in ProcessWire timezone; convert
				if ( $timezone != $this->gmt_offset )
				{
					$timezone = new DateTimeZone($this->config->timezone);
					$date->setTimezone($timezone);
				} # end if

			}
			# else:
			else
			{
				$date = new DateTime($string_date);
			}

		}
		# catch: silent error; use the current datetime
		catch ( Exception $e )
		{
			$date = new DateTime($fallback);
		}

		return array(
			'has_timezone'	=> $has_timezone,
			'timezone' => $timezone,
			'date'			=> $date->format('Y-m-d H:i:s')
		);
	} # end method parseDateTime()


	/**
	 * This method records HTTP referers, to be processed as potential vouches
	 * @param string $referer
	 * @access public
	 * @return mixed
	 */
	public function recordReferer($referer = '')
	{

		# if: no referer to record
		if ( empty($_SERVER['HTTP_REFERER']) )
		{
			return;
		}

		$referer = $_SERVER['HTTP_REFERER'];

		# if: do not track internal referers
		if ( parse_url($referer, PHP_URL_HOST) == $this->config->httpHost )
		{
			return;
		}

		$trimmed_referer = trim(str_replace(array('http://', 'https://'), '', $referer), '/');

		# if: do not track referers from a homepage; expectation is that content changes periodically.
		if ( parse_url($referer, PHP_URL_HOST) == $trimmed_referer )
		{
			return;
		}

		$referer = $this->sanitizer->url($referer);

		$statement = $this->database->prepare("SELECT * FROM {$this->className}_vouches WHERE url = ?");
		$result = $statement->execute(array($referer));

		if ( $result === FALSE || $statement->rowCount() > 0 )
		{
			return;
		}

		$statement = $this->database->prepare("INSERT INTO {$this->className}_referer_queue SET url = ?, created = NOW(), modified = NOW() ON DUPLICATE KEY UPDATE modified = NOW()");
		$result = $statement->execute(array($referer));

		return;
	} # end method recordReferer()


	/**
	 * This method handles processing referers to determine if they can be used as a vouch
	 * @access public
	 * @return mixed
	 */
	public function processReferer()
	{
		set_time_limit(0);

		$result = $this->database->query("SELECT * FROM {$this->className}_referer_queue WHERE processed IS NULL ORDER BY created ASC LIMIT 1");

		if ( $result === FALSE || $result->rowCount() == 0 )
		{
			return;
		}

		$row = $result->fetch(PDO::FETCH_ASSOC);

		$http = new WireHttp();
		$response = $http->get($row['url']);

		libxml_use_internal_errors(TRUE);
		$dom = new DOMDocument('1.0', 'UTF-8');
		$dom->loadHTML($response);
		$dom->preserveWhiteSpace = FALSE;

		# get <a> DOMElements
		$a_elements = $dom->getElementsByTagName('a');

		$statement_vouches = $this->database->prepare("INSERT INTO {$this->className}_vouches SET domain = ?, url = ?, created = NOW(), modified = NOW() ON DUPLICATE KEY UPDATE modified = NOW()");

		$ignore_domains = array(
			'brid.gy',
			'google.com',
			'yahoo.com',
			'bing.com',
			't.co',
		);

		# loop: each <a> DOMElement
		foreach ( $a_elements as $a )
		{
			$rel = $a->getAttribute('rel');
			$href = $a->getAttribute('href');

			$domain = preg_replace('#^www\.(.+\.)#i', '$1', parse_url($row['url'], PHP_URL_HOST));

			# if: domain is not ignored, link does not have rel=nofollow, and links back
			if ( !in_array($domain, $ignore_domains) && ($rel != 'nofollow') && strpos($href, $this->config->httpHost) !== FALSE )
			{
				$url = $this->sanitizer->url($row['url']);
				$result = $statement_vouches->execute(array($domain, $url));

				break;
			} # end if

		} # end loop

		$statement = $this->database->prepare("UPDATE {$this->className}_referer_queue SET processed = NOW() WHERE id = ?");
		$result = $statement->execute(array($row['id']));

		return;
	} # end method processReferer()


	/**
	 * This method verifies a received vouch URL
	 * @param string $vouch_url
	 * @param string $source_url
	 * @access public
	 * @see https://indieweb.org/Vouch
	 */
	public function verifyReceivedVouch($vouch_url, $source_url)
	{
		$http = new WireHttp();

		$approved_vouches = explode("\n", $this->approved_vouches);
		$approved_vouches = array_map('trim', $approved_vouches);

		$vouch_domain = parse_url($vouch_url, PHP_URL_HOST);
		$source_domain = parse_url($source_url, PHP_URL_HOST);
		$source_base_url = parse_url($source_url, PHP_URL_SCHEME) . '://' . $source_domain;

		# if: vouch domain is not accepted
		if ( !in_array($vouch_domain, $approved_vouches) )
		{
			$this->log->save('webmentions-received', sprintf('Vouch domain %s not approved.', $vouch_domain));
			return FALSE;
		}

		set_time_limit(0);

		$response = $http->get($vouch_url);

		libxml_use_internal_errors(TRUE);
		$dom = new DOMDocument('1.0', 'UTF-8');
		$dom->loadHTML($response);
		$dom->preserveWhiteSpace = FALSE;

		# get <a> DOMElements
		$a_elements = $dom->getElementsByTagName('a');

		# loop: each <a> DOMElement
		foreach ( $a_elements as $a )
		{
			$rel = $a->getAttribute('rel');
			$href = $a->getAttribute('href');

			# if: vouch URL links to source domain and does *not* have rel=nofollow
			if ( strpos($href, $source_domain) !== FALSE && ($rel != 'nofollow') )
			{
				return TRUE;
			} # end if

		}

		$this->log->save('webmentions-received', sprintf('Vouch %s does not link to %s with rel=nofollow.', $vouch_url, $source_domain));
		return FALSE;
	} # end method verifyReceivedVouch()


	/**
	 * This method attempts to find a vouch URL for sending webmentions
	 * @param string $url
	 * @access public
	 * @return bool|string
	 * @see https://indieweb.org/Vouch
	 */
	public function findVouchFor($url)
	{
		$domain = preg_replace('#^www\.(.+\.)#i', '$1', parse_url($url, PHP_URL_HOST));

		$ignore_domains = array(
			$this->config->httpHost,
			'brid.gy',
			'google.com',
			'yahoo.com',
			'bing.com',
			't.co',
		);

		# if: ignore vouch for this domain
		if ( in_array($domain, $ignore_domains) )
		{
			return FALSE;
		} # end if

		$http = new WireHttp();

		$checked_domains = array();

		$domain = parse_url($url, PHP_URL_HOST);
		$base_url = parse_url($url, PHP_URL_SCHEME) . '://' . $domain;

		# First check if this domain is in the vouches table (they already link to us); if so, use that for vouch
		$result = $this->database->query("SELECT * FROM {$this->className}_vouches WHERE domain = '{$domain}' AND `deleted` IS NULL");

		# if: db/query error
		if ( $result === FALSE )
		{
			return FALSE;
		}
		# else if: vouch found
		else if ( $result->rowCount() > 0 )
		{
			$row = $result->fetch(PDO::FETCH_ASSOC);
			return $row['url'];
		} # end if

		$response = $http->get($url);

		libxml_use_internal_errors(TRUE);
		$dom = new DOMDocument('1.0', 'UTF-8');
		$dom->loadHTML($response);
		$dom->preserveWhiteSpace = FALSE;

		# get <a> DOMElements
		$a_elements = $dom->getElementsByTagName('a');

		# loop: each <a> DOMElement
		foreach ( $a_elements as $a )
		{
			$rel = $a->getAttribute('rel');
			$href = $a->getAttribute('href');

			# if: link does not have rel=nofollow
			if ( ($rel != 'nofollow') )
			{
				$full_url = Mf2\resolveUrl($base_url, $href);
				$potential_vouch_domain = parse_url($full_url, PHP_URL_HOST);

				# if: link is external and domain has not already been checked
				if ( $potential_vouch_domain != $domain && !in_array($potential_vouch_domain, $checked_domains) )
				{
					$checked_domains[] = $potential_vouch_domain;

					# check vouches
					$result = $this->database->query("SELECT * FROM {$this->className}_vouches WHERE domain = '{$potential_vouch_domain}'");

					if ( $result === FALSE || $result->rowCount() == 0 )
					{
						continue;
					}

					$row = $result->fetch(PDO::FETCH_ASSOC);
					return $row['url'];
				} # end if: link is external...

			} # end if: link does not have...

		} # end loop: each <a>

		return FALSE;
	} # end method findVouchFor()


	/**
	 * This method processes the vouch_whitelist URL and adds any new vouch domains found there
	 * @access protected
	 * @return bool
	 */
	protected function processVouchWhitelist()
	{

		if ( !$this->vouch_whitelist )
		{
			return FALSE;
		}

		$has_new_domains = FALSE;

		# retrieve the module's config data; break out approved vouch domains into array
		$data = $this->modules->getModuleConfigData($this);
		$approved_vouches = explode("\n", $data['approved_vouches']);

		# fetch the vouch_whitelist page
		$http = new WireHttp();
		$response = $http->get($this->vouch_whitelist);

		# if: microformats collection
		if ( $collection = $this->fetchMicroformats($response, $this->vouch_whitelist) )
		{
			$cards = Mf2helper\findMicroformatsByType($collection, 'h-card');

			# loop: each h-card
			foreach ( $cards as $card )
			{
				$url = Mf2helper\getPlaintext($card, 'url');
				$domain = preg_replace('#^www\.(.+\.)#i', '$1', parse_url($url, PHP_URL_HOST));

				# if: domain is not in approved vouches yet; add it
				if ( !in_array($domain, $approved_vouches) )
				{
					$has_new_domains = TRUE;
					$approved_vouches[] = $domain;
				} # end if

			} # end loop

		} # end if

		# if: need to update the config
		if ( $has_new_domains )
		{
			# alpha sort the domains, implode to a string, and save
			sort($approved_vouches);
			$data['approved_vouches'] = implode("\n", $approved_vouches);
			$this->modules->saveModuleConfigData($this, $data);
		} # end if

		return TRUE;
	} # end method processVouchWhitelist()


	/**
	 * This method searches the FieldtypeWebmentions
	 * @param string $selector_string
	 * @access public
	 * @return WebmentionArray
	 */
	public function find($selector_string)
	{

		# if: webmention field already found
		if ( $this->webmention_field )
		{
			$field = $this->webmention_field;
		}
		# else: look for first webmention field
		else
		{

			# loop: each field
			foreach ( $this->fields as $field )
			{

				# if: add FieldtypeWebmentions to $fields array
				if ( $field->type instanceof FieldtypeWebmentions )
				{
					break;
				} # end if

			} # end loop

		} # end if

		return $field->type->find($field, $selector_string);
	} # end method find()


	/**
	 * Update database schema
	 *
	 * This method applies incremental updates until latest schema version is
	 * reached, while also keeping schema_version config setting up to date.
	 *
	 */
	private function updateDatabaseSchema()
	{

		# loop:
		while ( $this->schema_version < self::SCHEMA_VERSION )
		{
			++$this->schema_version;

			switch ( $this->schema_version )
			{
				case 2:
					$sql = "ALTER TABLE {$this->className}_send_queue ADD pages_id INT(10) UNSIGNED NOT NULL DEFAULT 0 AFTER id";
				break;

				case 3:
					$sql = "ALTER TABLE {$this->className}_send_queue ADD params TEXT AFTER vouch ";
				break;

				default:
					throw new WireException("Unrecognized database schema version: $this->schema_version");
				break;
			}

			if ( $sql && $this->database->exec($sql) !== FALSE )
			{
				$config_data = $this->modules->getModuleConfigData($this);
				$config_data['schema_version'] = $this->schema_version;
				$this->modules->saveModuleConfigData($this, $config_data);
			}
			else
			{
				throw new WireException("Couldn't update database schema to version $this->schema_version");
			}

		} # end loop

	} # end method updateDatabaseSchema()

}

